---
title: "Herbivory on urban reefs foraging responses of coral reef fishes across turbidity gradients"
author: "K. Grellman"
date: "5/7/2024"
output: html_document
editor_options: 
  chunk_output_type: inline
---



#################### Setup ####################

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, Load libraries, message=F, warning=F, echo=F}
library(corrplot)
library(ggplot2)
library(cowplot) 
theme_set(theme_cowplot()) 
library(lme4)
library(MuMIn)
library(car)
library(MASS)
library(lmtest)
library(robustbase)
library(languageR)
library(lmerTest)
library(tidyverse)
library(tidyr)
library(selectapref)
library(reshape2)
library(plyr) # must be loaded BEFORE dplyr
library(dplyr)
library(RColorBrewer)
library(stringr)
library(gridExtra)
library(viridis)
library(performance)
library(rsq)
library(png)
library(fishualize)
library(devtools)
library(ggpubr)
library(ggplot2)
library(lsmeans)
library(multcompView)
library(tibble)
library(broom)
library(quantreg)
library(jtools)
library(segmented)

```

```{r, Load data, message=F, warning=F, echo=F}
follows.dat <- read.csv("/Users/Kat/Documents/2_Research/Fish Follows Manuscript/GitHub/Fish_follows.csv")

rawben.dat <- read.csv("/Users/Kat/Documents/2_Research/Fish Follows Manuscript/GitHub//Supp_Benthic_Data.csv")
```

```{r, Load graphics, message=F, warning=F, echo=F}

# Fish silouettes
zv.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Fishualize Silouettes/Acanthuridae_Zebrasoma.velifer.png")
nl.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Fishualize Silouettes/Acanthuridae_Naso.lituratus.png")
nu.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Fishualize Silouettes/Acanthuridae_Naso.unicornis.png")
zf.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Fishualize Silouettes/Acanthuridae_Zebrasoma.scopas.zf.png")
ab.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Fishualize Silouettes/Acanthuridae_Ctenochaetus.striatus.ab.png")
at.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Fishualize Silouettes/manini.png")
cs.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Fishualize Silouettes/Labridae_Chlorurus.sordidus.cs.png")
sp.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Fishualize Silouettes/Labridae_Scarus.oviceps.sp.png")

# Benthic cateegories
turf.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Graphics/epilithic-algae.png")
cca.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Graphics/coralline-algae.png")
macro.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Graphics/lobaria-pulmonaria.png")
rock.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Graphics/rocks-2.png")
rubble.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Graphics/rocks-1.png")
coral.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Graphics/pocillopora-meandrina-cauliflower-coral.png")
sponge.img <- readPNG("/Users/Kat/Documents/2_Research/Thesis Resources/10_Thesis/Data Analysis/Graphics/neoesperiopsis-rigida-orange-finger-sponge.png")
  
# Sources: Integration and Application Network, University of Maryland (https://github.com/nschiett/fishualize) and Fishualize R Package (https://github.com/nschiett/fishualize). 

```

#################### Data Exploration ####################

```{r, PLOTS - Histogram, distribution of bites per minute}
# Histogram - all substrates
ggplot(data=follows.dat) +
  geom_histogram(aes(x=total)) +
   facet_wrap( ~ location)

```

```{r, PLOTS -  Visibility vs. turbidity}

y <- vis.dat$visibility.m
x <- vis.dat$turbidity.ntu

vis.dat <- follows.dat[!is.na(as.numeric(follows.dat$visibility.m)), ]
vis.dat <- vis.dat %>%
  mutate(visibility.m = as.numeric(visibility.m))

visex.plot <- ggplot(vis.dat,mapping=aes(x=turbidity.ntu,y=as.numeric(visibility.m), na.rm=TRUE)) +
  geom_point() +
  geom_smooth(data = subset(vis.dat, turbidity.ntu <= 4.0),
              method = "lm",
              formula = y ~ log(x),
              se = FALSE, show.legend = FALSE,
              linetype = "solid") +
  geom_smooth(
              method = "lm",
              formula = y ~ log(x),
              se = FALSE, show.legend = FALSE,
              linetype = "dashed") +
  xlab("Turbidity (NTU)") +
  ylab("Horizontal Visibility (m)")
print(visex.plot) 
#ggsave("visex.plot.jpg", visex.plot, width=6, height=4, dpi=300)


# SE visibility
visA.dat <- vis.dat %>%
  filter(site.grp == "A")
str(visA.dat)
visB.dat <- vis.dat %>%
  filter(site.grp == "B")
visC.dat <- vis.dat %>%
  filter(site.grp == "C")
mean(visC.dat$visibility.m)
sd.f <- sd(visC.dat$visibility.m)
n.f <- length(visC.dat$visibility.m)
se.f <- sd.f/sqrt(n.f)
print(se.f)


```

```{r, ANOVA - Grouping sites by turbidity measurements}

ggplot(follows.dat, aes(x=turbidity.ntu)) + 
  geom_histogram(bins=30)

turb.aov <- aov(turbidity.ntu~site.id, follows.dat)
summary(turb.aov)
TukeyHSD(turb.aov)

# Check for homogeneity of variances
residuals <- residuals(turb.aov)
fitted_values <- fitted(turb.aov)

# Plot residuals vs fitted values
plot(fitted_values, residuals,
     xlab = "Fitted Values",
     ylab = "Residuals",
     main = "Residuals vs Fitted Values")
abline(h = 0, col = "red")

# NO DIFFERENCES:
# L2S1-L1S2 
# L2S2-L1S2 
# L3S2-L1S2 
# L3S3-L1S2 
# L2S3-L1S3 
# L2S2-L2S1 
# L3S2-L2S1
# L3S3-L2S1
# L3S2-L2S2  
# L3S3-L2S2
# L3S3-L3S2 

# GROUP A: L1S1, L3S1
# GROUP B: L1S3, L2S3
# GROUP C: L1S2, L2S1, L2S2, L3S2, L3S3

# Visualize tukey test
plotmeans(turbidity.ntu ~ site.id, data = follows.dat,
          xlab = "Site ID", ylab = "Mean Turbidity (NTU)")
abline(h = c(1.5, 2), lty = 2)
text(x = par("usr")[1] - 0.1, y = c(1.3, 1.75, 2.6), labels = c("Low (Control)", "Medium", "High"), pos = 4, col="red")

```

```{r, PLOTS - Spatial NTU trends}

# Define the desired order of levels
custom_order <- c("C", "B", "A")
# Convert site.grp to a factor with custom order
follows.dat$site.grp <- factor(follows.dat$site.grp, levels = custom_order)

# Boxplot showing distribution of turbidity measurements across sites
turb.spatial <- ggplot(follows.dat,aes(x=as.factor(site.grp),y=turbidity.ntu)) +
  geom_boxplot(alpha=.7, fill=c("#D2B48C", "#B5651D", "#3E1F0D")) +
  stat_summary(position=position_dodge(width=.75), geom="point",color="black",size=3) +
  xlab("Mean Turbidity") +
  ylab("Turbidity (NTU)") +
  scale_x_discrete(labels=c("Low", "Medium", "High")) +
  scale_y_continuous(breaks=seq(0,7,by=.5), limits=c(0,7)) +
      theme(
  axis.title.x = element_text(size=24),  # X axis title size
    axis.title.y = element_text(size=24),  # Y axis title size
    axis.text.x = element_text(size=20),   # X axis labels size
    axis.text.y = element_text(size=20))  # Y axis labels size
print(turb.spatial)
ggsave("turb.spatial.jpg", turb.spatial)

# Mean and median turbidity values at each site
tapply(follows.dat$turbidity.ntu,follows.dat$site.grp, mean)
tapply(follows.dat$turbidity.ntu,follows.dat$site.grp, range)
tapply(follows.dat$turbidity.ntu,follows.dat$site.grp, sd)

# SE Turbidity
siteA.dat <- follows.dat %>%
  filter(site.grp == "A")
siteB.dat <- follows.dat %>%
  filter(site.grp == "B")
siteC.dat <- follows.dat %>%
  filter(site.grp == "C")
mean(siteA.dat$turbidity.ntu)
sd.f <- sd(siteA.dat$turbidity.ntu)
n.f <- length(siteA.dat$turbidity.ntu)
se.f <- sd.f/sqrt(n.f)
print(se.f)


# SE Benthic Comp
View(rawben.dat)
tapply(rawben.dat$Branching.Coral, rawben.dat$SiteGrp, se)
benA.dat <- follows.dat %>%
  filter(SiteGrp == "A")

std_error <- function(x) {
  sd(x) / sqrt(length(x))
}

benthic_columns <- c("Branching.Coral", "Rubble", "Rock", "Sponge", 
                     "Sand", "Plate.coral", "CCA", "Turf.Algae", "Macro.Algae")
# High Turb
se_resultsA <- rawben.dat %>%
  filter(SiteGrp == "A") %>%
  summarise(
    Branching = std_error(Branching.Coral),
    Rubble = std_error(Rubble),
    Rock = std_error(Rock),
    Sponge = std_error(Sponge),
    Sand = std_error(Sand),
    CCA = std_error(CCA),
    Turf = std_error(Turf.Algae),
    Macro = std_error(Macro.Algae))
print(se_resultsA)

# Medium Turb
se_resultsB <- rawben.dat %>%
  filter(SiteGrp == "B") %>%
  summarise(
    Branching = std_error(Branching.Coral),
    Rubble = std_error(Rubble),
    Rock = std_error(Rock),
    Sponge = std_error(Sponge),
    Sand = std_error(Sand),
    CCA = std_error(CCA),
    Turf = std_error(Turf.Algae),
    Macro = std_error(Macro.Algae))
print(se_resultsB)

# Low Turb
se_resultsC <- rawben.dat %>%
  filter(SiteGrp == "C") %>%
  summarise(
    Branching = std_error(Branching.Coral),
    Rubble = std_error(Rubble),
    Rock = std_error(Rock),
    Sponge = std_error(Sponge),
    Sand = std_error(Sand),
    CCA = std_error(CCA),
    Turf = std_error(Turf.Algae),
    Macro = std_error(Macro.Algae))
print(se_resultsC)


```

```{r, SAMPLE SIZES OF TURBIDITY MEASUREMENTS}
a.dat <- follows.dat %>%
  filter(site.grp=="A")
length(unique(a.dat$turbidity.ntu))
b.dat <- follows.dat %>%
  filter(site.grp=="B")
length(unique(b.dat$turbidity.ntu))
c.dat <- follows.dat %>%
  filter(site.grp=="C")
length(unique(c.dat$turbidity.ntu))

length(unique(follows.dat$turbidity.ntu))
```

```{r, PLOTS - Stacked barchart of benthic comp across locations/sites}
# Create long df of benthic data
benthic.dat <- follows.dat %>%
  select(site,location,site.grp,bc.branching,bc.rubble,bc.rock,bc.sand,bc.sponge,bc.plate,bc.cca,bc.turf,bc.macro)
head(benthic.dat)
benthic.long <- benthic.dat %>%
  pivot_longer(cols=-c(site, location, site.grp), names_to="benthic_type",values_to="percent_cover")

## Stacked percent barchart ##

# Reorder levels
benthic.long$benthic_type <- factor(benthic.long$benthic_type, 
                                    levels = c("bc.branching", "bc.plate", "bc.cca", "bc.sponge", "bc.rock", "bc.rubble", "bc.sand", "bc.macro", "bc.turf"))


# Create color palette
bc.colors <- c("#80cdc1", "#35978f", "#003c30", "#FFA500","#3E2723", "#bf812d", "#dfc27d", "#4d9221", "#7fbc41")

# Define the desired order of levels
custom_order <- c("C", "B", "A")
# Convert site.grp to a factor with custom order
benthic.long$site.grp <- factor(benthic.long$site.grp, levels = custom_order)

benthic.plot <- ggplot(benthic.long, aes(x=as.factor(site.grp), y=percent_cover, fill=benthic_type, color=benthic_type)) + 
  geom_bar(position="fill", stat="identity") +
  xlab("Mean Turbidity") + 
  ylab("Benthic Composition") +
  scale_x_discrete(label=c("Low", "Medium", "High")) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_manual(values=bc.colors, name = "Benthic Category", labels = c("Branching Coral", "Plate Coral", "CCA", "Sponge", "Rock", "Rubble", "Sand", "Macroalgae", "Turf")) +
  scale_color_manual(values=bc.colors, name="Benthic Category", labels = c("Branching Coral", "Plate Coral", "CCA", "Sponge", "Rock", "Rubble", "Sand", "Macroalgae", "Turf")) +
     theme(
    axis.title.x = element_text(size=24),  # X axis title size
    axis.title.y = element_text(size=24),  # Y axis title size
    axis.text.x = element_text(size=20),   # X axis labels size
    axis.text.y = element_text(size=20))
print(benthic.plot)
ggsave("benthic.plot.jpg",benthic.plot, width=8, height=6, dpi=300)

# Combine with spatial turbidity figure
sites.plot <- ggarrange(turb.spatial, common.legend=TRUE, legend="right", benthic.plot, ncol=1, nrow=2)
print(sites.plot)
ggsave("sites.plot.jpg", sites.plot, height=11, width=8, dpi=300)

```

```{r, ANOVA, Benthic composition}
# Define the benthic categories
benthic_categories <- c("Branching.Coral", "Rubble", "Rock", "Sand", "Sponge", "Plate.coral", "CCA", "Turf.Algae", "Macro.Algae")
check <- aov(bc.branching~site.grp, follows.dat)
summary(check)

ggplot(rawben.dat, aes(x=Branching.Coral)) +
  geom_histogram()
ggplot(rawben.dat, aes(x=Rubble)) +
  geom_histogram() 
ggplot(rawben.dat, aes(x=Rock)) +
  geom_histogram()
ggplot(rawben.dat, aes(x=Sand)) +
  geom_histogram()
ggplot(rawben.dat, aes(x=Sponge)) +
  geom_histogram()
ggplot(rawben.dat, aes(x=Plate.coral)) +
  geom_histogram()
ggplot(rawben.dat, aes(x=CCA)) +
  geom_histogram()
ggplot(rawben.dat, aes(x=Turf.Algae)) +
  geom_histogram()
ggplot(rawben.dat, aes(x=Macro.Algae)) +
  geom_histogram()

# Function to run ANOVA and TukeyHSD
run_anova <- function(category) {
  formula <- as.formula(paste(category, "~ SiteGrp"))
  aov_result <- aov(formula, data = rawben.dat)
  tukey_result <- TukeyHSD(aov_result)
  list(aov = aov_result, tukey = tukey_result)
}

# Apply the function to each benthic category
results <- lapply(benthic_categories, run_anova)

# Assign names to the results list for easier access
names(results) <- benthic_categories

# Extract ANOVA summaries and format them
anova_results <- bind_rows(lapply(names(results), function(category) {
  tidy(results[[category]]$aov) %>% mutate(Category = category)
}))

# Extract Tukey HSD summaries and format them
tukey_results <- bind_rows(lapply(names(results), function(category) {
  tidy(results[[category]]$tukey) %>% mutate(Category = category)
}))

# Print the ANOVA results table
print(anova_results)

# Print the Tukey HSD results table
print(tukey_results)
write.csv(tukey_results, "benthic_tukey_results.csv", row.names = FALSE)

```

```{r, PLOTS - Size of fish across locations/sites}

spatialsize.plot <- ggplot(follows.dat, aes(x=site.grp, y=tl, fill=as.factor(site.grp))) +
  geom_boxplot(alpha=0.7) +
  stat_summary(fun=mean, position=position_dodge(width=.75), geom="point",color="black",size=3) +
  xlab("Site Grouping") + 
  ylab("Fish Total Length (cm)") +
  scale_fill_manual(values=c("#3E1F0D", "#B5651D", "#87CEEB")) +
  theme(legend.position="none")
print(spatialsize.plot)
#ggsave("spatialsize.plot.jpg", spatialsize.plot, width=6, height=4, dpi=300)

ggplot(follows.dat, aes(x=site.grp, y=tl, fill=as.factor(site.grp))) +
  geom_boxplot(alpha=0.7) +
  stat_summary(fun=mean, position=position_dodge(width=.75), geom="point",color="black",size=3) +
  xlab("Site Grouping") + 
  ylab("Fish Total Length (cm)") +
  scale_fill_manual(values=c("#3E1F0D", "#B5651D", "#87CEEB")) +
  theme(legend.position="none")

# Mean and median turbidity values at each site
tapply(follows.dat$tl,follows.dat$site.grp, mean)
tapply(follows.dat$tl,follows.dat$site.grp, median)
tapply(follows.dat$tl,follows.dat$site.grp, range)

```

```{r, PLOTS - Bite rates across fish size and temperature}
# Total length vs. bite rate
size.plot <- ggplot(follows.dat,aes(y=total,x=tl,color=as.factor(species))) +
  geom_smooth(method="lm") +
  xlab("Fish Total Length (cm)") +
  ylab("Bites per Minute") +
  labs(color = "Species") +
  scale_y_continuous(limits = c(0, NA)) +
  theme(legend.text = element_text(face = "italic"))
print(size.plot)
#ggsave("size.plot.jpg", size.plot, width=6, height=4, dpi=300)

# Temperature vs. bite rate
tempbite.plot <- ggplot(follows.dat,aes(y=total,x=temp.c,color=as.factor(species))) +
  geom_smooth(method="lm") +
  xlab("Temperature (˚C)") +
  ylab("Bites per Minute") +
  labs(color = "Species") +
  theme(legend.text = element_text(face = "italic"))
print(tempbite.plot)
#ggsave("tempbite.plot.jpg", tempbite.plot, width=6, height=4, dpi=300)

```

```{r, PLOTS - Bite rates across SuS gradient by species}

# N. lituratus
sum(follows.dat$species == "N. lituratus") # n = 11

nl.plot <- ggplot(subset(follows.dat,species=="N. lituratus"),aes(y=total,x=turbidity.ntu)) +
  geom_point(alpha=.4) +
  geom_smooth(method="glm",se=TRUE, color="purple") +
  scale_x_continuous(breaks=seq(0,7,by=1), limits=c(0,7)) +
   coord_cartesian(ylim = c(0,4)) +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("N. lituratus"))) +
  annotate("text", x = 5.2, y = 2.9, label = "n=11", vjust = 0, hjust = 0) +
  annotation_raster(nl.img, xmin = 4.8, xmax = 6.5, ymin = 3.3, ymax = 4)
print(nl.plot)

# Z. velifer
ggplot(subset(follows.dat,species=="Z. velifer"),aes(y=total,x=turbidity.ntu)) +
  geom_point(alpha=.4) +
  geom_smooth(method="lm",se=TRUE) +
  scale_x_continuous(breaks=seq(0,7,by=1), limits = c(0,7)) +
  xlab("Turbidity (NTU)") +
  ylab("Bites per Minute") +
  labs(title="Z. velifer") +
  annotate("text", x = 5.5, y = 42, label = "n=434", vjust = 0, hjust = 0) +
  annotation_raster(zv.img, xmin = 5.2, xmax = 6.5, ymin = 45, ymax = 55)

# Remove outlier and build new df
zvout.dat <- follows.dat %>%
  filter(turbidity.ntu<=5)

sum(zvout.dat$species == "Z. velifer") #n=433

# Z. velifer without outlier point
zv.outplot <- ggplot(subset(zvout.dat,species=="Z. velifer"),aes(y=total,x=turbidity.ntu)) +
  geom_point(alpha=.4) +
  geom_smooth(method="glm") +
    scale_x_continuous(breaks=seq(0,7,by=1), limits = c(0,7)) +
    scale_y_continuous(breaks=seq(0,60,by=10), limits = c(0,60)) +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("Z. velifer"))) +
  annotate("text", x = 5.3, y = 44, label = "n=433", vjust = 0, hjust = 0) +
  annotation_raster(zv.img, xmin = 5.5, xmax = 6.5, ymin = 50, ymax = 60)
print(zv.outplot)

# N. unicornis
sum(follows.dat$species == "N. unicornis") #n = 43

nu.plot <- ggplot(subset(follows.dat,species=="N. unicornis"),aes(y=total,x=turbidity.ntu)) +
  geom_point(alpha=.4) +
  geom_smooth(method="glm", se=TRUE, color="purple") +
  scale_x_continuous(breaks=seq(0,7,by=1), limits=c(0,7)) +
  xlab("") +
  ylab("") +
   labs(title=expression(italic("N. unicornis"))) +
   annotate("text", x = 5.2, y = 14.5, label = "n=43", vjust = 0, hjust = 0) +
   annotation_raster(nu.img, xmin = 4.9, xmax = 6.5, ymin = 16.5, ymax = 20)
print(nu.plot)
  
# A. triostegus
sum(follows.dat$species == "A. triostegus") #n = 490

at.plot <- ggplot(subset(follows.dat,species=="A. triostegus"),aes(y=total,x=turbidity.ntu)) +
  geom_point(alpha=.4) +
  geom_smooth(method="glm",se=TRUE) +
  scale_x_continuous(breaks=seq(0,7,by=1), limits=c(0,7)) +
   scale_y_continuous(breaks=seq(0,150,by=25), limits=c(0,150)) +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("A. triostegus"))) +
  annotate("text", x = 5.3, y = 113, label = "n=490", vjust = 0, hjust = 0) +
  annotation_raster(at.img, xmin = 5.3, xmax = 6.5, ymin = 125, ymax = 150)
print(at.plot)

# A. blochii
sum(follows.dat$species == "A. blochii") #n = 513

ab.plot <- ggplot(subset(follows.dat,species=="A. blochii"),aes(y=total,x=turbidity.ntu)) +
  geom_point(alpha=.4) +
  geom_smooth(method="glm") +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("A. blochii"))) +
  scale_x_continuous(breaks=seq(0,7,by=1), limits=c(0,7)) +
  annotate("text", x = 5.3, y = 73, label = "n=513", vjust = 0, hjust = 0) +
  annotation_raster(ab.img, xmin = 5.3, xmax = 6.5, ymin = 83, ymax = 100)
print(ab.plot)

# Z. flavescens
sum(follows.dat$species == "Z. flavescens") #n = 251

zf.plot <- ggplot(subset(follows.dat,species=="Z. flavescens"),aes(y=total,x=turbidity.ntu)) +
  geom_point(alpha=.4) +
  geom_smooth(method="glm",se=TRUE) +
  scale_x_continuous(breaks=seq(0,7,by=1), limits=c(0,7)) +
  scale_y_continuous(breaks=seq(0,70,by=10), limits=c(0,70)) +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("Z. flavescens"))) +
  annotate("text", x = 5.3, y = 50, label = "n=251", vjust = 0, hjust = 0) +
  annotation_raster(zf.img, xmin = 5.3, xmax = 6.5, ymin = 57, ymax = 70)
print(zf.plot)

# C. spilurus
sum(follows.dat$species == "C. spilurus ") #n = 408

cs.plot <- ggplot(subset(follows.dat,species=="C. spilurus "),aes(y=total,x=turbidity.ntu)) +
  geom_point(alpha=.4) +
  geom_smooth(method="glm",se=TRUE, color="green") +
  scale_x_continuous(breaks=seq(0,7,by=1),limits=c(0,7)) +
  scale_y_continuous(breaks=seq(0,60,by=10), limits=c(0,60)) +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("C. spilurus"))) +
  annotate("text", x = 5.3, y = 46, label = "n=408", vjust = 0, hjust = 0) +
  annotation_raster(cs.img, xmin = 5.2, xmax = 6.5, ymin = 51, ymax = 60)
print(cs.plot)

# S. psittacus
sum(follows.dat$species == "S. psittacus") #n = 482

sp.plot <- ggplot(subset(follows.dat,species=="S. psittacus"),aes(y=total,x=turbidity.ntu)) +
  geom_point(alpha=.4) +
  geom_smooth(method="lm",se=TRUE, color="green") +
  scale_x_continuous(breaks=seq(0,7,by=1), limits = c(0,7)) +
  scale_y_continuous(breaks=seq(0,70,by=10), limits = c(0,70)) +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("S. psittacus"))) +
  annotate("text", x = 5.3, y = 53, label = "n=482", vjust = 0, hjust = 0) +
  annotation_raster(sp.img, xmin = 5.2, xmax = 6.6, ymin = 59, ymax = 70)
print(sp.plot)

# Arrange final figure
bitegradient.plot <- ggarrange(ab.plot, at.plot, zv.outplot, zf.plot, nu.plot, nl.plot, sp.plot, cs.plot, ncol = 2, nrow = 4, align="hv")

fbitegradient.plot <- annotate_figure(bitegradient.plot,
                bottom = text_grob("Turbidity (NTU)", color = "black", size = 18),
                left = text_grob("Bites per Minute", color = "black", rot = 90, size=18))
#print(fbitegradient.plot)

#ggsave("fbitegradient.plot.jpg", fbitegradient.plot, height=10, width=6.5, dpi=300)

scraper.plot <-ggarrange(sp.plot, cs.plot, ncol = 2, nrow = 1, align="hv")
scraper.plot <- annotate_figure(scraper.plot,
                bottom = text_grob("Turbidity (NTU)", color = "black", size = 18),
                left = text_grob("Bites per Minute", color = "black", rot = 90, size=18))
print(scraper.plot)
ggsave("scraper.plot.jpg", scraper.plot)




```

```{r, DATA WRANGLING FOR JUVENILE/ADULT DF}
# A. triostegus
at.age <- follows.dat %>%
  filter(species == "A. triostegus") %>%
  mutate(tl.grp = ifelse(tl < 7.5 , "juvenile", ifelse(tl > 10.2, "adult", NA)))
# Remove NAs
at.age <- at.age[!is.na(at.age$tl.grp), ]
nrow(at.age[at.age$tl.grp == "juvenile", ]) # 196
nrow(at.age[at.age$tl.grp == "adult", ]) # 117

# A. blochii
ab.age <- follows.dat %>%
  filter(species == "A. blochii") %>%
  mutate(tl.grp = ifelse(tl < 7.5, "juvenile", ifelse(tl > 12, "adult", NA)))
# Remove NAs
ab.age <- ab.age[!is.na(ab.age$tl.grp), ]
nrow(ab.age[ab.age$tl.grp == "juvenile", ]) # 182
nrow(ab.age[ab.age$tl.grp == "adult", ]) # 117

tapply(ab.age$total, ab.age$tl.grp, mean)

# Z. flavescens
zf.age <- follows.dat %>%
  filter(species == "Z. flavescens") %>%
    mutate(tl.grp = ifelse(tl < 6.3, "juvenile", ifelse(tl > 8.3, "adult", NA))) 
# remove NAs
zf.age <- zf.age[!is.na(zf.age$tl.grp), ]
nrow(zf.age[zf.age$tl.grp == "juvenile", ]) # 46
nrow(zf.age[zf.age$tl.grp == "adult", ]) # 155


# Z. velifer
View(zvout)
zv.age <- zvout %>%
      mutate(tl.grp = ifelse(tl < 6.3, "juvenile", ifelse(tl > 10.3, "adult", NA)))
# Remove NAs
zv.age <- zv.age[!is.na(zv.age$tl.grp), ]
nrow(zv.age[zv.age$tl.grp == "juvenile", ]) # 153
nrow(zv.age[zv.age$tl.grp == "adult", ]) # 133

# N. unicornis
nu.age <- follows.dat %>%
  filter(species == "N. unicornis") %>%
  mutate(tl.grp = ifelse(tl < 30, "juvenile", ifelse(tl > 34, "adult", NA)))
# Remove NAs
nu.age <- nu.age[!is.na(nu.age$tl.grp), ]
nrow(nu.age[nu.age$tl.grp == "juvenile", ]) # 43
nrow(nu.age[nu.age$tl.grp == "adult", ]) # 0

# N. lituratus
nl.age <- follows.dat %>%
  filter(species == "N. lituratus") %>%
  mutate(tl.grp = ifelse(tl < 30, "juvenile", ifelse(tl > 34, "adult", NA)))
# Remove NAs
nl.age <- nl.age[!is.na(nl.age$tl.grp), ]
nrow(nl.age[nl.age$tl.grp == "juvenile", ]) # 11
nrow(nl.age[nl.age$tl.grp == "adult", ]) # 0

# C. spilurus
cs.age <- follows.dat %>%
  filter(species == "C. spilurus ") %>%
  mutate(tl.grp = ifelse(tl < 15, "juvenile", ifelse(tl > 19.86, "adult", NA)))
# Remove NAs
cs.age <- cs.age[!is.na(cs.age$tl.grp), ]
nrow(cs.age[cs.age$tl.grp == "juvenile", ]) # 330
nrow(cs.age[cs.age$tl.grp == "adult", ]) # 8

# S. psittacus
sp.age <- follows.dat %>%
  filter(species == "S. psittacus") %>%
  mutate(tl.grp = ifelse(tl < 10.5, "juvenile", ifelse(tl > 14.8, "adult", NA)))
# Remove NAs
sp.age <- sp.age[!is.na(sp.age$tl.grp), ]
nrow(sp.age[sp.age$tl.grp == "juvenile", ]) # 404
nrow(sp.age[sp.age$tl.grp == "adult", ]) # 14


##### Calculate number of juveniles and adults #######

zv <- follows.dat %>%
  filter(species == "Z. velifer")
zv.age1 <- zv %>%
      mutate(tl.grp = ifelse(tl < 6.3, "juvenile", ifelse(tl > 10.3, "adult", NA)))
# Remove NAs
zv.age1 <- zv.age1[!is.na(zv.age1$tl.grp), ]
nrow(zv.age1[zv.age1$tl.grp == "juvenile", ]) # 154
nrow(zv.age1[zv.age1$tl.grp == "adult", ]) # 133
ontogeny.dat <- rbind(sp.age, cs.age, at.age, ab.age, zf.age, zv.age1)
View(ontogeny.dat)

ggplot(ontogeny.dat, aes(x=site.grp, y=tl, fill=as.factor(tl.grp), color=as.factor(tl.grp))) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), alpha = 0.6) +
  geom_boxplot(alpha=0.7) +
  stat_summary(fun=mean, position=position_dodge(width=.75), geom="point",color="black",size=3) +
  xlab("Site Grouping") + 
  ylab("Fish Total Length (cm)")

tapply(ontogeny.dat$tl.grp, ontogeny.dat$site.grp, count)
tapply(ontogeny.dat$tl.grp, ontogeny.dat$site.grp, count)

```

```{r, PLOTS - Juvenile/adult bite rates across SuS gradients}
# Z. velifer 
nrow(zv.age) # 286
zvage.plot <- ggplot(zv.age,aes(y=total,x=turbidity.ntu, color=tl.grp, fill=tl.grp)) +
  geom_point(alpha=.7) +
  geom_smooth(method="glm") +
    scale_x_continuous(breaks=seq(0,7,by=1), limits = c(0,7)) +
    scale_y_continuous(breaks=seq(0,60,by=10), limits = c(0,60)) +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("Z. velifer"))) +
  scale_fill_manual(values=c("#BF5200", "#003c30"), name="", labels = c("Adult", "Juvenile")) +
  scale_color_manual(values=c("#BF5200", "#003c30"), name ="", labels = c("Adult", "Juvenile")) +
  annotate("text", x = 5.3, y = 44, label = "n=286", vjust = 0, hjust = 0) +
  annotation_raster(zv.img, xmin = 5.5, xmax = 6.5, ymin = 50, ymax = 60)
print(zvage.plot)

# A. triostegus
nrow(at.age) # 313

atage.plot <- ggplot(at.age,aes(y=total,x=turbidity.ntu, color=tl.grp, fill=tl.grp)) +
  geom_point(alpha=.7) +
  geom_smooth(method="glm",se=TRUE) +
  scale_x_continuous(breaks=seq(0,7,by=1), limits=c(0,7)) +
   scale_y_continuous(breaks=seq(0,150,by=25), limits=c(0,150)) +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("A. triostegus"))) +
  scale_fill_manual(values=c("#BF5200", "#003c30"), name="", labels = c("Adult", "Juvenile")) +
  scale_color_manual(values=c("#BF5200", "#003c30"), name ="", labels = c("Adult", "Juvenile")) +
  annotate("text", x = 5.3, y = 108, label = "n=313", vjust = 0, hjust = 0) +
  annotation_raster(at.img, xmin = 5.3, xmax = 6.5, ymin = 123, ymax = 150)
print(atage.plot)

# A. blochii
nrow(ab.age) # 299

abage.plot <- ggplot(ab.age,aes(y=total,x=turbidity.ntu, color=tl.grp, fill=tl.grp)) +
  geom_point(alpha=.7) +
  geom_smooth(method="glm") +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("A. blochii"))) +
  scale_x_continuous(breaks=seq(0,7,by=1), limits=c(0,7)) +
  scale_fill_manual(values=c("#BF5200", "#003c30"), name="", labels = c("Adult", "Juvenile")) +
  scale_color_manual(values=c("#BF5200", "#003c30"), name ="", labels = c("Adult", "Juvenile")) +
  annotate("text", x = 5.3, y = 73, label = "n=299", vjust = 0, hjust = 0) +
  annotation_raster(ab.img, xmin = 5.3, xmax = 6.5, ymin = 83, ymax = 100)
print(abage.plot)

# Z. flavescens
nrow(zf.age) # 201

zfage.plot <- ggplot(zf.age,aes(y=total,x=turbidity.ntu, color=tl.grp, fill=tl.grp)) +
  geom_point(alpha=.7) +
  geom_smooth(method="glm",se=TRUE) +
  scale_x_continuous(breaks=seq(0,7,by=1), limits=c(0,7)) +
  scale_y_continuous(breaks=seq(0,70,by=10), limits=c(0,70)) +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("Z. flavescens"))) +
  scale_fill_manual(values=c("#BF5200", "#003c30"), name="", labels = c("Adult", "Juvenile")) +
  scale_color_manual(values=c("#BF5200", "#003c30"), name ="", labels = c("Adult", "Juvenile")) +
  annotate("text", x = 5.3, y = 50, label = "n=201", vjust = 0, hjust = 0) +
  annotation_raster(zf.img, xmin = 5.3, xmax = 6.5, ymin = 57, ymax = 70)
print(zfage.plot)

# C. spilurus
nrow(cs.age) # 338

csage.plot <- ggplot(cs.age,aes(y=total,x=turbidity.ntu, color=tl.grp, fill=tl.grp)) +
  geom_point(alpha=.7) +
  geom_smooth(method="glm",se=TRUE) +
  scale_x_continuous(breaks=seq(0,7,by=1),limits=c(0,7)) +
  scale_y_continuous(breaks=seq(0,60,by=10), limits=c(0,60)) +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("C. spilurus^"))) +
  scale_fill_manual(values=c("#BF5200", "#003c30"), name="", labels = c("Adult", "Juvenile")) +
  scale_color_manual(values=c("#BF5200", "#003c30"), name ="", labels = c("Adult", "Juvenile")) +
  annotate("text", x = 5.3, y = 46, label = "n=338", vjust = 0, hjust = 0) +
  annotation_raster(cs.img, xmin = 5.2, xmax = 6.5, ymin = 51, ymax = 60)
print(csage.plot)

# S. psittacus
nrow(sp.age) # 418

spage.plot <- ggplot(sp.age,aes(y=total,x=turbidity.ntu, color=tl.grp, fill=tl.grp)) +
  geom_point(alpha=.7) +
  geom_smooth(method="lm",se=TRUE) +
  scale_x_continuous(breaks=seq(0,7,by=1), limits = c(0,7)) +
  scale_y_continuous(breaks=seq(0,70,by=10), limits = c(0,70)) +
  xlab("") +
  ylab("") +
  labs(title=expression(italic("S. psittacus^"))) +
  scale_fill_manual(values=c("#BF5200", "#003c30"), name="", labels = c("Adult", "Juvenile")) +
  scale_color_manual(values=c("#BF5200", "#003c30"), name ="", labels = c("Adult", "Juvenile")) +
  annotate("text", x = 5.3, y = 53, label = "n=418", vjust = 0, hjust = 0) +
  annotation_raster(sp.img, xmin = 5.2, xmax = 6.6, ymin = 59, ymax = 70)
print(spage.plot)

# Arrange final figure
agebitegradient.plot <- ggarrange(abage.plot, atage.plot, zvage.plot, zfage.plot, spage.plot, csage.plot, ncol = 2, nrow = 3, align="hv", common.legend=TRUE, legend = "bottom")

agefbitegradient.plot <- annotate_figure(agebitegradient.plot,
                bottom = text_grob("Turbidity (NTU)", color = "black", size = 18),
                left = text_grob("Bites per Minute", color = "black", rot = 90, size=18))
print(agefbitegradient.plot)

#ggsave("agefbitegradient.plot.jpg", agefbitegradient.plot, height=10, width=8.5, dpi=300)

tapply(ab.age$turbidity.ntu, ab.age$tl.grp, range)
tapply(zv.age$turbidity.ntu, zv.age$tl.grp, range)
tapply(sp.age$turbidity.ntu, sp.age$tl.grp, range)

```

```{r, EXPLORATIVE PLOTS - Water quality params and biological variables vs. bite counts}
# Size = may have effect on total bites - INCLUDE (FIXED)
# Temp = may have effect on total bites - INCLUDE (FIXED)
# DO = not a major effect and slightly correlates with turbidity - DON'T INCLUDE
# Site & location = Random effects on total bites - INCLUDE (RANDOM)


## Size ##
ggplot(follows.dat,aes(y=total,color=as.factor(species))) +
  geom_smooth(mapping=aes(x=tl),method="lm") +
   scale_color_viridis(discrete=TRUE, name = "Species")

## Month ##
ggplot(follows.dat,aes(y=total.avg,x=as.integer(month), color=as.factor(functional))) +
  geom_smooth(method="lm", se=TRUE) +
  geom_smooth(se=TRUE) + 
  geom_point() +
  scale_x_continuous(breaks=seq(1,13,by=1)) +
  xlab("Month (Jan 2023 to Jan 2024)") +
  ylab("Bites per Minute")

## Temp ##
ggplot(follows.dat,aes(y=total,x=temp.c,color=as.factor(species))) +
  geom_smooth(method="lm") +
  xlab("Temperature (˚C)") +
  ylab("Bites per Minute") +
   scale_color_viridis(discrete=TRUE, name = "Functional Group")

## DO ##
ggplot(follows.dat,aes(y=total,color=as.factor(functional))) +
  geom_smooth(mapping=aes(x=do.mg.l),  method="lm")
ggplot(follows.dat,aes(y=total,color=as.factor(species))) +
  geom_smooth(mapping=aes(x=do.mg.l), method="lm")

# Correlation plot between predictor variables and response variable ('total' -total bites per minute)
pred.cor = cor(follows.dat[,c(23,11,16,21,43)], use="pairwise.complete")
corrplot.mixed(pred.cor) 
```

```{r, EXPLORATIVE PLOTS - Benthic composition and bite counts}
#Turf = Main food choice - INCLUDE
#Branching = heavy negative correlation with macro and turf - DON'T INCLUDE
#Macro = correlated with turf - DON'T INCLUDE 
#CCA = heavy negative correlation with rubble and sand - DON'T INCLUDE
#Rubble = heavy negative correlation with CCA - INCLUDE
#Sand = negative correlation with turf and CCA - DON'T INCLUDE

## Turf ##
ggplot(follows.dat,aes(y=total,color=as.factor(species))) +
  geom_smooth(mapping=aes(x=bc.turf))

## Branching ##
ggplot(follows.dat,aes(y=total,color=as.factor(species))) +
  geom_smooth(mapping=aes(x=bc.branching))

## Rubble ##
ggplot(follows.dat,aes(y=total,color=as.factor(species))) +
  geom_smooth(mapping=aes(x=bc.rubble))

##Macro##
ggplot(follows.dat,aes(y=total,color=as.factor(species))) +
  geom_smooth(mapping=aes(x=bc.macro))

##CCA##
ggplot(follows.dat,aes(y=total,color=as.factor(species))) +
  geom_smooth(mapping=aes(x=bc.cca))

# Correlation plot between benthos cateograites and total bites per minute
ben.cor = cor(follows.dat[,c(43,55:63)], use="pairwise.complete")
corrplot.mixed(ben.cor)

```

#################### Statistics - SuS Gradient ####################

```{r, DATA WRANGLING FOR TURBIDITY MODELS}
### SET UP DATA TABLE FOR MODELING ###
# Convert to factors
follows.dat$location=as.factor(follows.dat$location)
follows.dat$site=as.factor(follows.dat$site)
follows.dat$ses=as.factor(follows.dat$ses)
follows.dat$month=as.factor(follows.dat$month)

cs <- filter(follows.dat,species=="C. spilurus ") #create df
sp <- filter(follows.dat,species=="S. psittacus") #create df
manini <- filter(follows.dat,species=="A. triostegus") #create df
ab <- filter(follows.dat,species=="A. blochii") #create df 
zf <- filter(follows.dat,species=="Z. flavescens") #create df
zv <- filter(follows.dat,species=="Z. velifer") #create df
unis <- filter(follows.dat,functional=="Browser") #create df

```

```{r, TURBIDITY MODEL - C. spilurus}
ggplot(data=cs) +
  geom_histogram(aes(x=total), bins=20) #Negative binomial distribution

# Identify theta value                                                                                                             
cs1 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=1))
cs2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=2))
cs3 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=3))
cs4 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=4))

model.sel(list(cs1, cs2, cs3, cs4), rank=AICc)

cs2.1 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=2.1))
cs2.2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=2.2))
cs2.3 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=2.3))
cs2.4 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=2.4))
cs2.5 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=2.5))
cs2.6 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=2.6))
cs2.7 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=2.7))
cs2.8 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=2.8))
cs2.9 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=2.9))

model.sel(list(cs2, cs2.1, cs2.2, cs2.3, cs2.4, cs2.5, cs2.6, cs2.7, cs2.8, cs2.9), rank=AICc)
# theta = 2.1

# Check model params and select predictors based on AICc
cs.gl <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=cs, na.action=na.fail, family=neg.bin(theta=2.1))
summary(cs.gl)
plot(cs.gl)
qqnorm(resid(cs.gl))
qqline(resid(cs.gl))
acf(resid(cs.gl))
check_collinearity(cs.gl)
print(dredge(cs.gl))


cs.glm <- glmer(total ~ turbidity.ntu + tl + bc.rubble + (1|month) + (1|location/site), data=cs, family=neg.bin(theta=2.1))
summary(cs.glm)
plot(cs.glm)
qqnorm(resid(cs.glm))
qqline(resid(cs.glm))
acf(resid(cs.glm))
check_collinearity(cs.glm)
r2_nakagawa(cs.glm)
lme4::isSingular(cs.glm)

# Extract the coefficients
cs.co <- summary(cs.glm)$coefficients

# Calculate the effect size for TL
cs.tl <- exp(cs.co["tl", "Estimate"])  # Exponentiate the coefficient

# Convert to percentage change
(cs.tl - 1) * 100

# Calculate the confidence intervals
cs.ci <- confint(cs.glm, level=0.95)
cs.ci.tl <- exp(cs.ci["tl", ])  # Exponentiate the confidence intervals
(cs.ci.tl - 1) * 100

# Calculate the effect size for bc.rubble
cs.rub <- exp(cs.co["bc.rubble", "Estimate"])  # Exponentiate the coefficient

# Convert to percentage change
(cs.rub - 1) * 100

# Calculate the confidence intervals
cs.ci <- confint(cs.glm, level=0.95)
cs.ci.rub <- exp(cs.ci["bc.rubble", ])  # Exponentiate the confidence intervals
(cs.ci.rub - 1) * 100


```

```{r, QUANTILE REGRESSION PRACTICE 1 - separate species - DON'T USE}

# C. spilurus
cp9.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.9,data=cs)
summary(cp9.rq) 
residuals_sp_rq <- residuals(cp9.rq)
hist(residuals_sp_rq, main = "Histogram of Residuals", xlab = "Residuals")
# Check collinearity
cp.lm <- lm(total ~ turbidity.ntu + tl + temp.c + bc.turf, data=cs)
vif(cp.lm)

# S. psittacus
sp9.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.9, data=sp)
summary(sp9.rq)
sp7.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.7,data=sp)
summary(sp7.rq)
# Check collinearity
sp.lm <- lm(total ~ turbidity.ntu + tl + temp.c + bc.turf, data=sp)
vif(sp.lm)

# A. triostegus (manini)
man95.rq <- rq(total ~ turbidity.ntu + temp.c + bc.turf, tau=0.95, data=manini)
summary(man95.rq)
summ(man95.rq)
man9.rq <- rq(total ~ turbidity.ntu + temp.c + bc.turf, tau=0.9, data=manini)
summ(man9.rq)
man75.rq <- rq(total ~ turbidity.ntu + temp.c + bc.turf, tau=0.75, data=manini)
summ(man75.rq)
man5.rq <- rq(total ~ turbidity.ntu + temp.c + bc.turf, tau=0.5, data=manini)
summary(man5.rq)
man1.rq <- rq(total ~ turbidity.ntu + temp.c + bc.turf, tau=0.1, data=manini)
summary(man1.rq)
residuals_man_rq <- residuals(man1.rq)
hist(residuals_man_rq, main = "Histogram of Residuals", xlab = "Residuals")
# Check collinearity
man.lm <- lm(total ~ turbidity.ntu + tl + temp.c + bc.turf, data=manini)
vif(man.lm)

# A. blochii
ab9.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.9, data=ab)
summary(ab9.rq)

# Z. flavescens
zf9.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.9, data=zf)
summary(zf9.rq)

# Z. velifer
zv9.rq <- rq(total ~ turbidity.ntu, tau=0.9, data=zv)
summary(zv9.rq)
zv75.rq <- rq(total ~ turbidity.ntu, tau=0.75, data=zv)
summary(zv75.rq)
# Check collinearity
zv.lm <- lm(total ~ turbidity.ntu + tl + temp.c + bc.turf, data=zv)
vif(zv.lm)


# DON'T USE - MODEL 1 FIT - need to figure out for loop with summ() output 
# Loop through each species and fit quantile regression
quantiles <- c(0.10, 0.50, 0.75, 0.90, 0.95)  # Choose quantiles of interest

for (manini in unique(follows.dat$species)) {
  species.data <- subset(follows.dat, species == manini)
  
  for (q in quantiles) {
    model <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, 
                tau = q, data = species.data)
    cat("\nSpecies:", manini, "- Quantile:", q, "\n")
    print(summary(model))
  }
}

```

```{r, QUANTILE REGRESSION}

# STEPWISE MODEL SELECTION
# Check model fit 
formulas <- list(
  total ~ turbidity.ntu + tl + temp.c + bc.turf, #1
  total ~ turbidity.ntu + tl + temp.c, #2
  total ~ turbidity.ntu + tl, #3
  total ~ turbidity.ntu + temp.c, #4
  total ~ turbidity.ntu + bc.turf, #5
  total ~ turbidity.ntu + tl + bc.turf, #6
  total ~ turbidity.ntu + temp.c + bc.turf #7
)

# Apply rq for each formula and store results in a list
aic.ab <- lapply(formulas, function(f) rq(f, tau=0.5, data=ab))
model.sel(aic.ab, rank=AICc) #Model 1
aic.man <- lapply(formulas, function(f) rq(f, tau=0.5, data=manini))
model.sel(aic.man, rank=AICc) #Model 7
aic.zv <- lapply(formulas, function(f) rq(f, tau=0.5, data=zv))
model.sel(aic.zv, rank=AICc) #Model 2
aic.zf <- lapply(formulas, function(f) rq(f, tau=0.5, data=zf))
model.sel(aic.zf, rank=AICc) #Model 2
aic.sp <- lapply(formulas, function(f) rq(f, tau=0.5, data=sp))
model.sel(aic.sp, rank=AICc) #Model 1
aic.cs <- lapply(formulas, function(f) rq(f, tau=0.5, data=cs))
model.sel(aic.cs, rank=AICc) #Model 1


# A. blochii - Model 1
ab95.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.95, data=ab)
summ(ab95.rq, se="boot") 
summary(ab95.rq)
ab9.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.9, data=ab)
summ(ab9.rq, se="boot") 
summary(ab9.rq)
ab75.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.75, data=ab)
summ(ab75.rq, se="boot") 
summary(ab75.rq)
ab5.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.5, data=ab)
summ(ab5.rq, se="boot")
summary(ab5.rq)
ab1.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.1, data=ab)
summ(ab1.rq, se="boot")
summary(ab1.rq)
vif(lm(total ~ turbidity.ntu + tl + temp.c + bc.turf, data=ab)) # Check collinearity; all <5

# PLOT
# Define colorblind-friendly colors and line types
plot.colors <- c("0.1" = "#CC79A7", "0.5" = "#0072B2", "0.75" = "#009E73", "0.9" = "#E69F00", "0.95" = "#D55E00") # Use for all rq plots
ab.lines <- c("0.1" = "solid", "0.5" = "solid", "0.75" = "solid", "0.9" = "solid", "0.95" = "solid") #Edit for each species based on rq p-values

abq.plot <- ggplot(subset(follows.dat, species == "A. blochii"), aes(y = total, x = turbidity.ntu)) +
    geom_quantile(aes(color = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95))), 
                      linetype = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95)))), 
                  quantiles = c(0.95, 0.9, 0.75, 0.5, 0.1), size = 1, alpha=1) +
    scale_color_manual(name = expression(tau), values = plot.colors, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) +
    scale_linetype_manual(name = expression(tau), values = ab.lines, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) + 
    #geom_smooth(method = "glm", se = FALSE, color = "black", linetype = "dotted") +
    geom_point(alpha = 0.3, size=.7) +
    scale_x_continuous(breaks = seq(0, 7, by = 1), limits = c(0, 7)) +
    scale_y_continuous(breaks = seq(0, 100, by = 25), limits = c(0, 100)) +
    xlab("") +
    ylab("") +
    labs(title = expression(italic("A. blochii"))) +
    annotate("text", x = 5.3, y = 73, label = "n=513", vjust = 0, hjust = 0) +
  annotation_raster(ab.img, xmin = 5.3, xmax = 6.5, ymin = 83, ymax = 100)
print(abq.plot)

# A. triostegus (manini) - Model 7
man95.rq <- rq(total ~ turbidity.ntu + temp.c + bc.turf, tau=.95, data=manini)
summ(man95.rq, se="boot")  #P<0.05, -
summary(man95.rq) # CI includes zero
man9.rq <- rq(total ~ turbidity.ntu + temp.c + bc.turf, tau=0.9, data=manini)
summ(man9.rq, se="boot") #P<0.05, -
summary(man9.rq) # CI includes zero
man75.rq <- rq(total ~ turbidity.ntu + temp.c + bc.turf, tau=0.75, data=manini)
summ(man75.rq, se="boot")
summary(man75.rq)
man5.rq <- rq(total ~ turbidity.ntu + temp.c + bc.turf, tau=0.5, data=manini)
summ(man5.rq, se="boot")
summary(man5.rq)
man1.rq <- rq(total ~ turbidity.ntu + temp.c + bc.turf, tau=0.1, data=manini)
summ(man1.rq, se="boot")
summary(man1.rq)
vif(lm(total ~ turbidity.ntu + temp.c + bc.turf, data=manini)) # Check collinearity; all <5

turb_range <- seq(0, 5, by=0.1)
newdata_full <- data.frame(
  turbidity.ntu = turb_range,
  temp.c = median(manini$temp.c, na.rm=TRUE),
  bc.turf = median(manini$bc.turf, na.rm=TRUE)
)

preds_full <- predict(man95.rq, newdata = newdata_full)

plot(turb_range, preds_full, type="l", ylab="Foraging Rate (bites/min)", xlab="Turbidity (NTU)", main="90th Quantile Predicted Foraging Rate for Manini")

# PLOT
man.lines <- c("0.1" = "solid", "0.5" = "solid", "0.75" = "solid", "0.9" = "dashed", "0.95" = "dashed") #Edit for each species based on rq p-values

atq.plot <- ggplot(subset(follows.dat, species == "A. triostegus"), aes(y = total, x = turbidity.ntu)) +
    geom_quantile(aes(color = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95))), 
                      linetype = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95)))), 
                  quantiles = c(0.95, 0.9, 0.75, 0.5, 0.1), size = 1, alpha=1) +
    scale_color_manual(name = expression(tau), values = plot.colors, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) +
    scale_linetype_manual(name = expression(tau), values = man.lines, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) + 
    #geom_smooth(method = "glm", se = FALSE, color = "black", linetype = "dotted") +
    geom_point(alpha = 0.3, size=.7) +
    scale_x_continuous(breaks = seq(0, 7, by = 1), limits = c(0, 7)) +
    scale_y_continuous(breaks = seq(0, 150, by = 25), limits = c(0, 150)) +
    xlab("") +
    ylab("") +
    labs(title = expression(italic("A. triostegus"))) +
  annotate("text", x = 5.3, y = 113, label = "n=490", vjust = 0, hjust = 0) +
  annotation_raster(at.img, xmin = 5.3, xmax = 6.5, ymin = 125, ymax = 150)
print(atq.plot)

# Z. velifer - Model 2
zv95.rq <- rq(total ~ turbidity.ntu + tl + temp.c, tau=0.95, data=zvout)
summ(zv95.rq, se="boot") 
summary(zv95.rq)
zv9.rq <- rq(total ~ turbidity.ntu + tl + temp.c, tau=0.9, data=zvout)
summ(zv9.rq, se="boot") 
summary(zv9.rq)
zv75.rq <- rq(total ~ turbidity.ntu + tl + temp.c, tau=0.75, data=zvout)
summ(zv75.rq, se="boot") 
summary(zv75.rq)
zv5.rq <- rq(total ~ turbidity.ntu + tl + temp.c, tau=0.5, data=zvout)
summ(zv5.rq, se="boot") #P<0.05, +
summary(zv5.rq) # CI doesn't include zero
zv1.rq <- rq(total ~ turbidity.ntu + tl + temp.c, tau=0.1, data=zvout)
summ(zv1.rq, se="boot")
summary(zv1.rq)
vif(lm(total ~ turbidity.ntu + tl + temp.c, data=zvout)) # Check collinearity; all <5

#PLOT
zv.lines <- c("0.1" = "solid", "0.5" = "dashed", "0.75" = "solid", "0.9" = "solid", "0.95" = "solid") #Edit for each species based on rq p-values

zvq.plot <- ggplot(zvout, aes(y = total, x = turbidity.ntu)) +
    geom_quantile(aes(color = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95))), 
                      linetype = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95)))), 
                  quantiles = c(0.95, 0.9, 0.75, 0.5, 0.1), size = 1, alpha=1) +
    scale_color_manual(name = expression(tau), values = plot.colors, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) +
    scale_linetype_manual(name = expression(tau), values = zv.lines, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) + 
    #geom_smooth(method = "glm", se = FALSE, color = "black", linetype = "dotted") +
    geom_point(alpha = 0.3, size=.7) +
    scale_x_continuous(breaks = seq(0, 7, by = 1), limits = c(0, 7)) +
    scale_y_continuous(breaks=seq(0,60,by=10), limits = c(0,60)) +
    xlab("") +
    ylab("") +
    labs(title = expression(italic("Z. velifer"))) +
    annotate("text", x = 5.3, y = 44, label = "n=433", vjust = 0, hjust = 0) +
  annotation_raster(zv.img, xmin = 5.5, xmax = 6.5, ymin = 50, ymax = 60)
print(zvq.plot)

# Z. flavescens - Model 2
zf95.rq <- rq(total ~ turbidity.ntu + tl + temp.c, tau=0.95, data=zf)
summ(zf95.rq, se="boot") #P<0.05, -
summary(zf95.rq) # CI includes zero
zf9.rq <- rq(total ~ turbidity.ntu + tl + temp.c, tau=0.9, data=zf)
summ(zf9.rq, se="boot") 
summary(zf9.rq)
zf75.rq <- rq(total ~ turbidity.ntu + tl + temp.c, tau=0.75, data=zf)
summ(zf75.rq, se="boot") 
summary(zf75.rq)
zf5.rq <- rq(total ~ turbidity.ntu + tl + temp.c, tau=0.5, data=zf)
summ(zf5.rq, se="boot") 
summary(zf5.rq)
zf1.rq <- rq(total ~ turbidity.ntu + tl + temp.c, tau=0.1, data=zf)
summ(zf1.rq, se="boot")
summary(zf1.rq)
vif(lm(total ~ turbidity.ntu + tl + temp.c, data=zf)) # Check collinearity; all <5

#PLOT
zf.lines <- c("0.1" = "solid", "0.5" = "solid", "0.75" = "solid", "0.9" = "solid", "0.95" = "dashed") #Edit for each species based on rq p-values

zfq.plot <- ggplot(zf, aes(y = total, x = turbidity.ntu)) +
    geom_quantile(aes(color = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95))), 
                      linetype = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95)))), 
                  quantiles = c(0.95, 0.9, 0.75, 0.5, 0.1), size = 1, alpha=1) +
    scale_color_manual(name = expression(tau), values = plot.colors, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) +
    scale_linetype_manual(name = expression(tau), values = zf.lines, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) + 
    #geom_smooth(method = "glm", se = FALSE, color = "black", linetype = "dotted") +
    geom_point(alpha = 0.3, size=.7) +
    scale_x_continuous(breaks = seq(0, 7, by = 1), limits = c(0, 7)) +
    scale_y_continuous(breaks=seq(0,70,by=10), limits=c(0,70)) +
    xlab("") +
    ylab("") +
    labs(title = expression(italic("Z. flavescens"))) +
  annotate("text", x = 5.3, y = 50, label = "n=251", vjust = 0, hjust = 0) +
  annotation_raster(zf.img, xmin = 5.3, xmax = 6.5, ymin = 57, ymax = 70)
print(zfq.plot)


# S. psittacus - Model 1
sp95.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.95, data=sp)
summ(sp95.rq, se="boot") 
summary(sp95.rq) 
sp9.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.9, data=sp)
summ(sp9.rq, se="boot") 
summary(sp9.rq)
sp75.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.75, data=sp)
summ(sp75.rq, se="boot") #P<0.05, +
summary(sp75.rq) # doesn't include zero
sp5.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.5, data=sp)
summ(sp5.rq, se="boot") #P<0.05, +
summary(sp5.rq) # doesn't include zero
sp1.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.1, data=sp)
summ(sp1.rq, se="boot")
summary(sp1.rq)
vif(lm(total ~ turbidity.ntu + tl + temp.c + bc.turf, data=sp)) # Check collinearity; all <5

# PLOT
sp.lines <- c("0.1" = "solid", "0.5" = "dashed", "0.75" = "dashed", "0.9" = "solid", "0.95" = "solid") #Edit for each species based on rq p-values

spq.plot <- ggplot(subset(follows.dat, species == "S. psittacus"), aes(y = total, x = turbidity.ntu)) +
    geom_quantile(aes(color = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95))), 
                      linetype = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95)))), 
                  quantiles = c(0.95, 0.9, 0.75, 0.5, 0.1), size = 1, alpha=1) +
    scale_color_manual(name = expression(tau), values = plot.colors, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) +
    scale_linetype_manual(name = expression(tau), values = sp.lines, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) + 
    #geom_smooth(method = "glm", se = FALSE, color = "black", linetype = "dotted") +
    geom_point(alpha = 0.3, size=.7) +
    scale_x_continuous(breaks = seq(0, 7, by = 1), limits = c(0, 7)) +
    scale_y_continuous(breaks=seq(0,70,by=10), limits = c(0,70)) +
    xlab("") +
    ylab("") +
    labs(title = expression(italic("S. psittacus"))) +
    annotate("text", x = 5.3, y = 53, label = "n=482", vjust = 0, hjust = 0) +
    annotation_raster(sp.img, xmin = 5.2, xmax = 6.6, ymin = 59, ymax = 70)
print(spq.plot)

# C. spilurus - Model 1
cs95.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=.95, data=cs)
summ(cs95.rq, se="boot") 
summary(cs95.rq) 
cs9.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.9, data=cs)
summ(cs9.rq, se="boot") 
summary(cs9.rq) 
cs75.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.75, data=cs)
summ(cs75.rq, se="boot") #P<0.05, +
summary(cs75.rq) # doesn't include zero
cs5.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.5, data=cs)
summ(cs5.rq, se="boot")
summary(cs5.rq)
cs1.rq <- rq(total ~ turbidity.ntu + tl + temp.c + bc.turf, tau=0.1, data=cs)
summ(cs1.rq, se="boot")
summary(cs1.rq)
vif(lm(total ~ turbidity.ntu + tl + temp.c + bc.turf, data=cs)) # Check collinearity; all <5

# PLOT
cs.lines <- c("0.1" = "solid", "0.5" = "solid", "0.75" = "dashed", "0.9" = "solid", "0.95" = "solid") #Edit for each species based on rq p-values

csq.plot <- ggplot(cs, aes(y = total, x = turbidity.ntu)) +
    geom_quantile(aes(color = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95))), 
                      linetype = factor(..quantile.., levels = rev(c(0.1, 0.5, 0.75, 0.9, 0.95)))), 
                  quantiles = c(0.95, 0.9, 0.75, 0.5, 0.1), size = 1, alpha=1) +
    scale_color_manual(name = expression(tau), values = plot.colors, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) +
    scale_linetype_manual(name = expression(tau), values = cs.lines, labels=c("0.95", "0.90", "0.75", "0.50", "0.10")) + 
    #geom_smooth(method = "glm", se = FALSE, color = "black", linetype = "dotted") +
    geom_point(alpha = 0.3, size=.7) +
    scale_x_continuous(breaks = seq(0, 7, by = 1), limits = c(0, 7)) +
    scale_y_continuous(breaks=seq(0,60,by=10),limits=c(0,60)) +
    xlab("") +
    ylab("") +
    labs(title = expression(italic("C. spilurus"))) +
    annotate("text", x = 5.3, y = 46, label = "n=408", vjust = 0, hjust = 0) +
    annotation_raster(cs.img, xmin = 5.2, xmax = 6.5, ymin = 51, ymax = 60)
print(csq.plot)

qr.plot <- ggarrange(abq.plot, atq.plot, zvq.plot, zfq.plot, spq.plot, csq.plot, ncol = 2, nrow = 3, align="hv", common.legend=TRUE, legend="right")
fqr.plot <- annotate_figure(qr.plot,
                bottom = text_grob("Turbidity (NTU)", color = "black", size = 18),
                left = text_grob("Bites per Minute", color = "black", rot = 90, size=18))

ggsave("fqr.plot.jpg", fqr.plot, height=10, width=8, dpi=300)

```

```{r, QUANTILE REGRESSION OUTPUT}
# Extract summaries
s95 <- summary(man95.rq, se = "boot")$coefficients
s90 <- summary(man9.rq, se = "boot")$coefficients
s75 <- summary(man75.rq, se = "boot")$coefficients
s50 <- summary(man5.rq, se = "boot")$coefficients
s10 <- summary(man1.rq, se = "boot")$coefficients

# Convert to data frames
df95 <- as.data.frame(s95)
df90 <- as.data.frame(s90)
df75 <- as.data.frame(s75)
df50 <- as.data.frame(s50)
df10 <- as.data.frame(s10)

# Optionally, add a column for quantile
df95$tau <- 0.95
df90$tau <- 0.90
df75$tau <- 0.75
df50$tau <- 0.50
df10$tau <- 0.10

# Combine all into one data frame
all_quantiles <- rbind(df95, df90, df75, df50, df10)
all_quantiles$predictor <- rep(rownames(s95), times = 5)  # assumes same predictors for all models

# Reorder columns
all_quantiles <- all_quantiles[, c("tau", "predictor", "Value", "Std. Error", "t value", "Pr(>|t|)")]

# Export to CSV
write.csv(all_quantiles, "quantile_regression_summary.csv", row.names = FALSE)
```


```{r, QUANTILE REGRESSION PRACTICE 3 - DON"T USE}

# MODEL 1 FIT - need to figure out for loop with summ() output 
# Loop through each species and fit quantile regression
quantiles <- c(0.10, 0.50, 0.75, 0.90, 0.95)  # Choose quantiles of interest

for (sp in unique(follows.dat$species)) {
  species.data <- subset(follows.dat, species == sp)
  
  for (q in quantiles) {
    model <- rq(total ~ turbidity.ntu + temp.c + bc.turf, 
                tau = q, data = species.data)
    cat("\nSpecies:", sp, "- Quantile:", q, "\n")
    print(summary(model))
  }
}

# Graph coefficients - Manini
quantiles <- seq(0.05, 0.95, by = 0.05)  # From 5th to 95th percentile
models <- lapply(quantiles, function(q) {
  rq(total ~ turbidity.ntu + temp.c + tl, tau = q, data = manini)
})

# Extract coefficients for turbidity across quantiles
coef_turb <- sapply(models, function(m) coef(m)["turbidity.ntu"])
coef_df <- data.frame(Quantile = quantiles, Turbidity_Effect = coef_turb)

# Plot the turbidity effect across quantiles
ggplot(coef_df, aes(x = Quantile, y = Turbidity_Effect)) +
  geom_line(color = "blue", size = 1) +
  geom_point(color = "red") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(title = "Effect of Turbidity on Foraging Rate Across Quantiles",
       x = "Quantile", y = "Turbidity Coefficient (Effect on Foraging Rate)")

```

```{r, TURBIDITY MODEL - S. psittacus}
ggplot(data=sp) +
  geom_histogram(aes(x=total), bins=20) # Negative binomial distribution


# Identify theta value                                                                                                             
sp1 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=1))
sp2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=2))
sp3 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=3))
sp4 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=4))

model.sel(list(sp1, sp2, sp3, sp4), rank=AICc)
sp3.5 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=3.5))
model.sel(list(sp3, sp4, sp3.5), rank=AICc)

sp3 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=3))
sp3.1 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=3.1))
sp3.2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=3.2))
sp3.3 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=3.3))
sp3.4 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=3.4))
sp3.5 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=3.5))
model.sel(list(sp3, sp3.1, sp3.2, sp3.3, sp3.4, sp3.5), rank=AICc)
# theta = 3

# Check model params and select predictors based on AICc
sp.gl <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, na.action=na.fail, family=neg.bin(theta=3))
summary(sp.gl)
plot(sp.gl)
qqnorm(resid(sp.gl))
qqline(resid(sp.gl))
acf(resid(sp.gl))
check_collinearity(sp.gl)
print(dredge(sp.gl))
lme4::isSingular(sp.gl)

# AICc = 0, fit is singular
sp.glm1 <- glmer(total ~ turbidity.ntu + temp.c + bc.turf + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=3))

# Check number of fish at each location/site
nrow(follows.dat[follows.dat$location == "L1 - South Bay" & follows.dat$site == "1" & follows.dat$species == "S. psittacus", ])
nrow(follows.dat[follows.dat$location == "L1 - South Bay" & follows.dat$site == "2" & follows.dat$species == "S. psittacus", ])
nrow(follows.dat[follows.dat$location == "L1 - South Bay" & follows.dat$site == "3" & follows.dat$species == "S. psittacus", ])
nrow(follows.dat[follows.dat$location == "L2 - Mid Bay" & follows.dat$site == "1" & follows.dat$species == "S. psittacus", ])
nrow(follows.dat[follows.dat$location == "L2 - Mid Bay" & follows.dat$site == "2" & follows.dat$species == "S. psittacus", ])
nrow(follows.dat[follows.dat$location == "L2 - Mid Bay" & follows.dat$site == "3" & follows.dat$species == "S. psittacus", ])
nrow(follows.dat[follows.dat$location == "L3 - North Bay" & follows.dat$site == "1" & follows.dat$species == "S. psittacus", ])
nrow(follows.dat[follows.dat$location == "L3 - North Bay" & follows.dat$site == "2" & follows.dat$species == "S. psittacus", ])
nrow(follows.dat[follows.dat$location == "L3 - North Bay" & follows.dat$site == "3" & follows.dat$species == "S. psittacus", ])

# AICc = 1.53
sp.glm <- glmer(total ~ turbidity.ntu + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=sp, family=neg.bin(theta=3))
lme4::isSingular(sp.glm)
summary(sp.glm)
plot(sp.glm)
qqnorm(resid(sp.glm))
qqline(resid(sp.glm))
acf(resid(sp.glm))
check_collinearity(sp.glm)
r2_nakagawa(sp.glm)

# Extract the coefficients
sp.co <- summary(sp.glm)$coefficients

# Calculate the effect size for temperature (temp.c)
sp.temp <- exp(sp.co["temp.c", "Estimate"])  # Exponentiate the coefficient

# Convert to percentage change
(sp.temp - 1) * 100

# Calculate the confidence intervals
sp.ci <- confint(sp.glm, level=0.95)
sp.ci.temp <- exp(sp.ci["temp.c", ])  # Exponentiate the confidence intervals
(sp.ci.temp - 1) * 100

# Calculate the effect size for bc.turf
sp.tuf <- exp(sp.co["bc.turf", "Estimate"])  # Exponentiate the coefficient

# Convert to percentage change
(sp.tuf - 1) * 100

# Calculate the confidence intervals
sp.ci <- confint(cs.glm, level=0.95)
sp.ci.tl <- exp(sp.ci["bc.turf", ])  # Exponentiate the confidence intervals
(sp.ci.tl - 1) * 100

confint(cs.glm, level=0.95)

```

```{r, TURBIDITY MODEL - A. triostegus}
ggplot(data=manini) +
  geom_histogram(aes(x=total))
ggplot(data=manini) +
  geom_histogram(aes(x=sqrt(total)))

# Check model params and select predictors
m.lm <- lmer(sqrt(total) ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|site.id), data=manini, na.action=na.fail, REML=FALSE)
summary(m.lm)
plot(m.lm)
qqnorm(resid(m.lm))
qqline(resid(m.lm))
acf(resid(m.lm))
check_collinearity(m.lm)
print(dredge(m.lm))

m.lm2 <- lmer(sqrt(total) ~ turbidity.ntu + temp.c + bc.rubble + (1|month) + (1|site.id), data=manini, REML=TRUE)
summary(m.lm2)
plot(m.lm2) 
qqnorm(resid(m.lm2))
qqline(resid(m.lm2))
acf(resid(m.lm2))
r2_nakagawa(m.lm2)
plot_model(m.lm2, type="pred")

# Extract values
m.est <- summary(m.lm2)$coefficients["temp.c", "Estimate"]

# Calculate the percent change
(exp(m.est^2) - 1) * 100

# Extract confidence intervals
conf_intervals <- confint(m.lm2, level = 0.95)


```

```{r, TURBIDITY MODEL - A. blochii}
ggplot(data=ab) +
  geom_histogram(aes(x=total)) # Negative binomial


# Identify theta value
ab1 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, family=neg.bin(theta=1))
ab2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, family=neg.bin(theta=2))
ab3 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, family=neg.bin(theta=3))
ab4 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, family=neg.bin(theta=4))
model.sel(list(ab1, ab2, ab3, ab4), rank=AICc)

ab1.5 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, family=neg.bin(theta=1.5))
model.sel(list(ab1, ab2, ab1.5), rank=AICc)

ab1 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, family=neg.bin(theta=1))
ab1.1 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, family=neg.bin(theta=1.1))
ab1.2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, family=neg.bin(theta=1.2))
ab1.3 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, family=neg.bin(theta=1.3))
ab1.4 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, family=neg.bin(theta=1.4))
ab1.5 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, family=neg.bin(theta=1.5))
model.sel(list(ab1, ab1.1, ab1.2, ab1.3, ab1.4, ab1.5), rank=AICc)
# theta = 1.2

# Check model params and select predictors
ab.gl <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=ab, na.action=na.fail, family=neg.bin(theta=1.2))
summary(ab.gl)
plot(ab.gl)
qqnorm(resid(ab.gl))
qqline(resid(ab.gl))
acf(resid(ab.gl))
check_collinearity(ab.gl)
print(dredge(ab.gl))

ab.glm <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.rubble + (1|month) + (1|location/site), data=ab, na.action=na.fail, family=neg.bin(theta=1.2))
summary(ab.glm)
plot(ab.glm)
qqnorm(resid(ab.glm))
qqline(resid(ab.glm))
acf(resid(ab.glm))
r2_nakagawa(ab.glm)
plot_model(ab.glm, type="pred")
mean(ab$total)

# Extract the coefficients
ab.co <- summary(ab.glm)$coefficients

# Calculate the effect size for temperature (temp.c)
ab.temp <- exp(ab.co["temp.c", "Estimate"])  # Exponentiate the coefficient

# Convert to percentage change
(ab.temp - 1) * 100

# Calculate the confidence intervals
ab.ci <- confint(ab.glm, level=0.95)
ab.ci.temp <- exp(ab.ci["temp.c", ])  # Exponentiate the confidence intervals
ab.ci.per.temp <- (ab.ci.temp - 1) * 100
print(ab.ci.per.temp)

# Calculate the effect size for TL (tl)
ab.tl <- exp(ab.co["tl", "Estimate"])  # Exponentiate the coefficient

# Convert to percentage change
(ab.tl - 1) * 100

# Calculate the confidence intervals
ab.ci.tl <- exp(ab.ci["tl", ])  # Exponentiate the confidence intervals
(ab.ci.tl - 1) * 100

```

```{r, TURBIDITY MODEL - Z. flavescens}

ggplot(data=zf) +
  geom_histogram(aes(x=total), bins=20) # Tweedie or Negative binomial

nbin <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=zf, na.action=na.fail, family=neg.bin(theta=1))
tweedie <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=zf, na.action=na.fail, family=tweedie(var.power=1.5))
plot(nbin)
qqnorm(resid(nbin))
qqline(resid(nbin))
plot(tweedie)
qqnorm(resid(tweedie))
qqline(resid(tweedie)) # Negative binomial is better fit

# Check number of observations at each location/site for random effects structure
nrow(follows.dat[follows.dat$location == "L1 - South Bay" & follows.dat$site == "1" & follows.dat$species == "Z. flavescens", ]) # 0 observations
nrow(follows.dat[follows.dat$location == "L1 - South Bay" & follows.dat$site == "2" & follows.dat$species == "Z. flavescens", ]) # 4 
nrow(follows.dat[follows.dat$location == "L1 - South Bay" & follows.dat$site == "3" & follows.dat$species == "Z. flavescens", ]) # 34
nrow(follows.dat[follows.dat$location == "L2 - Mid Bay" & follows.dat$site == "1" & follows.dat$species == "Z. flavescens", ]) # 57
nrow(follows.dat[follows.dat$location == "L2 - Mid Bay" & follows.dat$site == "2" & follows.dat$species == "Z. flavescens", ]) # 23
nrow(follows.dat[follows.dat$location == "L2 - Mid Bay" & follows.dat$site == "3" & follows.dat$species == "Z. flavescens", ]) # 25
nrow(follows.dat[follows.dat$location == "L3 - North Bay" & follows.dat$site == "1" & follows.dat$species == "Z. flavescens", ]) # 4
nrow(follows.dat[follows.dat$location == "L3 - North Bay" & follows.dat$site == "2" & follows.dat$species == "Z. flavescens", ]) # 54
nrow(follows.dat[follows.dat$location == "L3 - North Bay" & follows.dat$site == "3" & follows.dat$species == "Z. flavescens", ]) # 50

# Use 'site.id' instead of 'location/site' since didn't see many at some locatin/site combos

# Identify theta value
zf1 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|site.id), data=zf, na.action=na.fail, family=neg.bin(theta=1))
zf2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|site.id), data=zf, na.action=na.fail, family=neg.bin(theta=2))
zf3 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|site.id), data=zf, na.action=na.fail, family=neg.bin(theta=3))
zf4 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|site.id), data=zf, na.action=na.fail, family=neg.bin(theta=4))
model.sel(list(zf1, zf2, zf3, zf4), rank=AICc)

zf1.5 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|site.id), data=zf, na.action=na.fail, family=neg.bin(theta=1.5))
model.sel(list(zf1, zf2, zf1.5), rank=AICc)

zf1.1 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|site.id), data=zf, na.action=na.fail, family=neg.bin(theta=1.1))
zf1.2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|site.id), data=zf, na.action=na.fail, family=neg.bin(theta=1.2))
zf1.3 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|site.id), data=zf, na.action=na.fail, family=neg.bin(theta=1.3))
model.sel(list(zf1, zf1.1, zf1.2, zf1.3), rank=AICc)
# theta = 1

# Check model params and select predictors
zf.gl2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|site.id), data=zf, na.action=na.fail, family=neg.bin(theta=1))
summary(zf.gl2)
plot(zf.gl2)
qqnorm(resid(zf.gl2))
qqline(resid(zf.gl2))
acf(resid(zf.gl2))
check_collinearity(zf.gl2)
print(dredge(zf.gl2))

zf.glm <- glmer(total ~ turbidity.ntu + tl + bc.rubble + (1|month) + (1|site.id), data=zf, family=neg.bin(theta=1)) # delta AICc = 0.64 (3rd best model)
summary(zf.glm)
plot(zf.glm)
qqnorm(resid(zf.glm))
qqline(resid(zf.glm))
acf(resid(zf.glm))
r2_nakagawa(zf.glm)

# Extract the coefficients
zf.co <- summary(zf.glm)$coefficients

# Calculate the effect size for TL
zf.tl <- exp(zf.co["tl", "Estimate"])  # Exponentiate the coefficient

# Convert to percentage change
(zf.tl - 1) * 100

# Calculate the confidence intervals
zf.ci <- confint(zf.glm, level=0.95)
zf.ci.tl <- exp(zf.ci["tl", ])  # Exponentiate the confidence intervals
(zf.ci.tl - 1) * 100

```

```{r, TURBIDITY MODEL - Z. velifer}

# Remove outlier
zvout <- zv %>%
  filter(turbidity.ntu<=5)

ggplot(data=zvout) +
  geom_histogram(aes(x=total)) # Negative binomial

# Identify theta value
zv1 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=zvout, na.action=na.fail, family=neg.bin(theta=1))
zv2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=zvout, na.action=na.fail, family=neg.bin(theta=2))
zv3 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=zvout, na.action=na.fail, family=neg.bin(theta=3))
zv4 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=zvout, na.action=na.fail, family=neg.bin(theta=4))
model.sel(list(zv1, zv2, zv3, zv4), rank=AICc)

zv1.2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=zvout, na.action=na.fail, family=neg.bin(theta=1.2))
model.sel(list(zv1, zv1.2), rank=AICc)
# theta = 1

zv.gl <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.turf + bc.rubble + (1|month) + (1|location/site), data=zvout, na.action=na.fail, family=neg.bin(theta=1))
summary(zv.gl)
plot(zv.gl)
qqnorm(resid(zv.gl))
qqline(resid(zv.gl))
acf(resid(zv.gl))
check_collinearity(zv.gl)
print(dredge(zv.gl))

zv.glm <- glmer(turf ~ turbidity.ntu + tl + temp.c + (1|month) + (1|location/site), data=zvout, family=neg.bin(theta=2)) # delta AICc=1.81 (4th best model)
summary(zv.glm)
plot(zv.glm)
qqnorm(resid(zv.glm))
qqline(resid(zv.glm))
acf(resid(zv.glm))
r2_nakagawa(zv.glm)
plot_model(zv.glm, type="pred")

# Extract the coefficients
zv.co <- summary(zv.glm)$coefficients

# Calculate the effect size for temperature (temp.c)
zv.temp <- exp(zv.co["temp.c", "Estimate"])  # Exponentiate the coefficient

# Convert to percentage change
(zv.temp - 1) * 100


# Calculate the confidence intervals
zv.ci <- confint(zv.glm, level=0.95)
zv.ci.temp <- exp(zv.ci["temp.c", ])  # Exponentiate the confidence intervals
(zv.ci.temp - 1) * 100

# Calculate the effect size for TL (tl)
zv.tl <- exp(zv.co["tl", "Estimate"])  # Exponentiate the coefficient

# Convert to percentage change
zv.tl.per <- (zv.tl - 1) * 100
print(zv.tl.per)

# Calculate the confidence intervals
zv.ci <- confint(zv.glm, level=0.95)
zv.ci.tl <- exp(zv.ci["tl", ])  # Exponentiate the confidence intervals
zv.ci.per.tl <- (zv.ci.tl - 1) * 100
print(zv.ci.per.tl)
```

```{r, TURBIDITY MODEL - N. unicornis and N. lituratus}
# Run with macro instead of turf as predictor since macro is main food choice

# Identify theta value
u1 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.macro + bc.rubble + (1|month) + (1|site), data=unis, na.action=na.fail, family=neg.bin(theta=1))
u2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.macro + bc.rubble + (1|month) + (1|site), data=unis, na.action=na.fail, family=neg.bin(theta=2))
u3 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.macro + bc.rubble + (1|month) + (1|site), data=unis, na.action=na.fail, family=neg.bin(theta=3))
u4 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.macro + bc.rubble + (1|month) + (1|site), data=unis, na.action=na.fail, family=neg.bin(theta=4))
model.sel(list(u1, u2, u3, u4), rank=AICc)

u1.2 <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.macro + bc.rubble + (1|month) + (1|site), data=unis, na.action=na.fail, family=neg.bin(theta=1.2))
model.sel(list(u1, u1.2), rank=AICc)
# theta = 1

# Check number of observations at each location/site for random effects structure
nrow(follows.dat[follows.dat$location == "L1 - South Bay" & follows.dat$species == "N. unicornis", ]) # 0
nrow(follows.dat[follows.dat$location == "L2 - Mide Bay" & follows.dat$species == "N. unicornis", ]) # 0
nrow(follows.dat[follows.dat$location == "L3 - North Bay" & follows.dat$species == "N. unicornis", ]) # 43
nrow(follows.dat[follows.dat$location == "L1 - South Bay" & follows.dat$species == "N. lituratus", ]) # 0 
nrow(follows.dat[follows.dat$location == "L2 - Mid Bay" & follows.dat$species == "N. lituratus", ]) # 0 
nrow(follows.dat[follows.dat$location == "L3 - North Bay" & follows.dat$species == "N. lituratus", ]) # 11

u.gl <- glmer(total ~ turbidity.ntu + tl + temp.c + bc.macro + bc.rubble + (1|month) + (1|site), data=unis, na.action=na.fail, family=neg.bin(theta=1)) # Only "site" as random effect instead of location/site since only seen at Location 3
summary(u.gl)
plot(u.gl)
qqnorm(resid(u.gl))
qqline(resid(u.gl))
acf(resid(u.gl))
print(dredge(u.gl))

# Delta AICc = 0
u.glm <- glmer(total ~ turbidity.ntu + bc.macro + bc.rubble + (1|month) + (1|site), data=unis, na.action=na.fail, family=neg.bin(theta=1)) # fail to converge
# Delta AICc = 1.27
u.glm2 <- glmer(total ~ bc.macro + bc.rubble + (1|month) + (1|site), data=unis, na.action=na.fail, family=neg.bin(theta=1)) # singular fit

# Delta AICc = 1.74
u.glm3 <- glmer(total ~ turbidity.ntu + bc.macro + (1|month) + (1|site), data=unis, family=neg.bin(theta=1))
summary(u.glm3)
plot(u.glm3)
qqnorm(resid(u.glm3))
qqline(resid(u.glm3))
acf(resid(u.glm3))
r2_nakagawa(u.glm3) # Conditional R2 may be over or under estimated

# Check coefficients
ggplot(unis, aes(x=turbidity.ntu, y=macro)) +
  geom_smooth(method="lm") +
  geom_point()

ggplot(unis, aes(x=turbidity.ntu, y=total)) +
  geom_smooth(method="lm") +
  geom_point()

# Extract the coefficients
uni.co <- summary(u.glm3)$coefficients

# Calculate the effect size for bc.macro
uni.mac <- exp(uni.co["bc.macro", "Estimate"])  # Exponentiate the coefficient

# Convert to percentage change
(uni.mac - 1) * 100

# Calculate the confidence intervals
uni.ci <- confint(u.glm3, level=0.95)
uni.ci.mac <- exp(uni.ci["bc.macro", ])  # Exponentiate the confidence intervals
(uni.ci.mac - 1) * 100


```

```{r, lstrends - Comparing bite rate slopes}

# Compare functional group slopes
fun.sl <- glmer(total ~ turbidity.ntu * functional + temp.c + (1|month), data=follows.dat, na.action=na.fail, family=neg.bin(theta=1.5))
summary(fun.sl)
plot(fun.sl)
qqnorm(resid(fun.sl))
qqline(resid(fun.sl))
acf(resid(fun.sl))
check_collinearity(fun.sl)
r2_nakagawa(fun.sl)
fun.trends <- lstrends(fun.sl, ~ functional, var="turbidity.ntu")
summary(fun.trends)
multcomp::cld(fun.trends)
pwpp(fun.trends) # No differences

# Compare species slopes
species.sl <- glmer(total ~ turbidity.ntu * species + bc.turf + (1|month) + (1|site.id), data=follows.dat, family=neg.bin(theta=2.5))
summary(species.sl)
plot(species.sl)
qqnorm(resid(species.sl))
qqline(resid(species.sl))
acf(resid(species.sl))
check_collinearity(species.sl)
r2_nakagawa(species.sl)

sp.trends <- lstrends(species.sl, ~ species, var="turbidity.ntu")
summary(sp.trends)
multcomp::cld(sp.trends)
pwpp.sp <- pwpp(sp.trends)
print(pwpp.sp) # Significant differences between species
print(pwpm(sp.trends))
#ggsave("pwpp.sp.jpg", pwpp.sp)

ggplot(follows.dat, aes(x=turbidity.ntu, y=total, color=species, fill=species)) +
  geom_jitter(alpha=.3) +
  geom_smooth(method="glm")

################################# SIZE GROUPS

# Compare size groups within each species

#######################  A. triostegus 


atage.sl <- lmer(sqrt(total) ~ turbidity.ntu * as.factor(tl.grp) + temp.c + bc.turf + (1|month) + (1|site.id), at.age, na.action=na.fail)
summary(atage.sl)
plot(atage.sl)
qqnorm(resid(atage.sl))
qqline(resid(atage.sl))
acf(resid(atage.sl))
check_collinearity(atage.sl)
r2_nakagawa(atage.sl)
# Compare slopes
atage.trends <- lstrends(atage.sl, ~ as.factor(tl.grp), var="turbidity.ntu")
summary(atage.trends)
multcomp::cld(atage.trends)
print(pwpp(atage.trends)) # No difference

ggplot(at.age, mapping=aes(x=turbidity.ntu, y=total, fill=as.factor(tl.grp), color=as.factor(tl.grp)))+
  geom_point() +
  geom_smooth(method="glm") +
  labs(title="A. triostegus")

#######################  A. blochii

abage.sl <- glmer(total ~ turbidity.ntu * as.factor(tl.grp) + temp.c + bc.turf + (1|month) + (1|site.id), ab.age, na.action=na.fail, family=neg.bin(theta=3)) 
summary(abage.sl)
plot(abage.sl)
qqnorm(resid(abage.sl))
qqline(resid(abage.sl))
acf(resid(abage.sl))
check_collinearity(abage.sl)
r2_nakagawa(abage.sl)
# Compare slopes
abage.trends <- lstrends(abage.sl, ~ as.factor(tl.grp), var="turbidity.ntu")
summary(abage.trends)
multcomp::cld(abage.trends)
print(pwpp(abage.trends)) # No difference

ggplot(ab.age, mapping=aes(x=turbidity.ntu, y=total, fill=as.factor(tl.grp), color=as.factor(tl.grp)))+
  geom_point() +
  geom_smooth(method="glm") +
  labs(title="A. blochii")

#######################  Z. flavescens

zfage.sl <- glmer(total ~ turbidity.ntu * as.factor(tl.grp) + (1|month) + (1|site.id), zf.age, na.action=na.fail, family=neg.bin(theta=1)) # Had to remove bc.turf and temp.c predictors for model to converge
summary(zfage.sl)
plot(zfage.sl)
qqnorm(resid(zfage.sl))
qqline(resid(zfage.sl))
acf(resid(zfage.sl))
check_collinearity(zfage.sl)
r2_nakagawa(zfage.sl)

# Compare slopes
zfage.trends <- lstrends(zfage.sl, ~ as.factor(tl.grp), var="turbidity.ntu")
summary(zfage.trends)
multcomp::cld(zfage.trends)
print(pwpp(zfage.trends)) # No difference

ggplot(zf.age, mapping=aes(x=turbidity.ntu, y=total, fill=as.factor(tl.grp), color=as.factor(tl.grp)))+
  geom_point() +
  geom_smooth(method="glm") +
  labs(title="Z. flavescens")

####################### Z. velifer

zvage.sl <- glmer(total ~ turbidity.ntu * as.factor(tl.grp) + temp.c + bc.turf + (1|month) + (1|site.id), zv.age, na.action=na.fail, family=neg.bin(theta=3)) 
summary(zvage.sl)
plot(zvage.sl)
qqnorm(resid(zvage.sl))
qqline(resid(zvage.sl))
acf(resid(zvage.sl))
check_collinearity(zvage.sl)
r2_nakagawa(zvage.sl)
# Compare slopes
zvage.trends <- lstrends(zvage.sl, ~ as.factor(tl.grp), var="turbidity.ntu")
summary(zvage.trends)
multcomp::cld(zvage.trends)
print(pwpp(zvage.trends)) # Adults decrease bite rate, juveniles increase bite rate
print(pwpm(zvage.trends))

ggplot(zv.age, mapping=aes(x=turbidity.ntu, y=total, fill=as.factor(tl.grp), color=as.factor(tl.grp)))+
  geom_point() +
  geom_smooth(method="glm") +
  labs(title="Z. velifer")

######################## C. spilurus juveniles
cs.juvenile <- cs.age %>%
  filter(tl.grp == "juvenile")
csage.sl <- glmer(total ~ turbidity.ntu  + temp.c + bc.turf + (1|month) + (1|site.id), cs.juvenile, na.action=na.fail, family=neg.bin(theta=1.5))
summary(csage.sl)
plot(csage.sl)
qqnorm(resid(csage.sl))
qqline(resid(csage.sl)) # turbidity has no effect

######################## S. psittacus juveniles
sp.juvenile <- sp.age %>%
  filter(tl.grp == "juvenile")
spage.sl <- glmer(total ~ turbidity.ntu  + temp.c + bc.turf + (1|month) + (1|site.id), sp.juvenile, na.action=na.fail, family=neg.bin(theta=2))
summary(spage.sl)
plot(spage.sl)
qqnorm(resid(spage.sl))
qqline(resid(spage.sl)) # turbidity has no effect




```

#################### Statistics - SeS vs. No SeS ####################

```{r, DATA WRANGLING FOR SeS MODELS}
# Data wrangling to remove rows with "-" ses values - Started taking SeS measurements in February 2023
ses.dat <- follows.dat %>%
  filter(ses != "-")
ses.dat$location <- as.factor(ses.dat$location)
ses.dat$site <- as.factor(ses.dat$site)
ses.dat$month <- as.factor(ses.dat$month)
ses.dat$ses <- as.factor(ses.dat$ses)

# Create dataframes
cs.ses.dat <- filter(ses.dat,species=="C. spilurus ") 
sp.ses.dat <- filter(ses.dat,species=="S. psittacus") 
manini.ses.dat <- filter(ses.dat,species=="A. triostegus")
ab.ses.dat <- filter(ses.dat,species=="A. blochii") 
zf.ses.dat <- filter(ses.dat,species=="Z. flavescens") 
zv.ses.dat <- filter(ses.dat,species=="Z. velifer") 
unis.ses.dat <- filter(ses.dat,species %in% c("N. unicornis", "N. lituratus"))

```

```{r, SES MODEL - C. spilurus}
## All substrates ##
cs.ses <- glmer(total ~ ses * bc.turf + tl + temp.c + (1|month) + (1|site.id), data=cs.ses.dat, family=neg.bin(theta=2.5))
summary(cs.ses)
plot(cs.ses)
qqnorm(resid(cs.ses)) 
qqline(resid(cs.ses))
check_collinearity(cs.ses) 
r2_nakagawa(cs.ses)

```

```{r, SES MODEL - S. psittacus}
## All substrates ##
sp.ses <- glmer(total ~ ses * bc.turf + tl + temp.c + (1|month) + (1|site.id), data=sp, family=neg.bin(theta=3))
summary(sp.ses)
plot(sp.ses)
qqnorm(resid(sp.ses)) 
qqline(resid(sp.ses))
check_collinearity(sp.ses) 
r2_nakagawa(sp.ses)

```

```{r, SES MODEL - A. triostegus}
## All substrates ##
m.ses <- lmer(sqrt(total) ~ ses * bc.turf + temp.c + tl + (1|month) + (1|site.id), data=manini.ses.dat)
summary(m.ses)
plot(m.ses)
qqnorm(resid(m.ses)) 
qqline(resid(m.ses))
check_collinearity(m.ses) 
r2_nakagawa(m.ses)

```

```{r, SES MODEL - A. blochii}
## All substrates ##
ab.ses <- glmer(total ~ ses * bc.turf + tl + temp.c + (1|month) + (1|site.id), data=ab.ses.dat, family=neg.bin(theta=1.2))
summary(ab.ses)
plot(ab.ses)
qqnorm(resid(ab.ses))
qqline(resid(ab.ses))
r2_nakagawa(ab.ses)

```

```{r, SES MODEL - Z. flavescens}
## All substrates ##
zf.ses <- glmer(total ~ ses * bc.turf + tl + temp.c + (1|month) + (1|site.id), data=zf.ses.dat, family=neg.bin(theta=1))
summary(zf.ses)
plot(zf.ses)
qqnorm(resid(zf.ses))
qqline(resid(zf.ses))
r2_nakagawa(zf.ses) # Conditioanl R2 may be under or over estimated

```

```{r, SES MODEL - Z. velifer}
## All substrates ##
zv.ses <- glmer(total ~ ses * bc.turf + tl + temp.c + (1|month) + (1|site.id), data=zv.ses.dat, family=neg.bin(theta=1))
summary(zv.ses)
plot(zv.ses)
qqnorm(resid(zv.ses))
qqline(resid(zv.ses))
r2_nakagawa(zv.ses)

```

```{r, SES MODEL - N. unicornis and lituratus}
## All substrates ##
uses.nb <- glmer(total ~ ses * bc.turf + tl + temp.c + (1|month) + (1|site), data=unis.ses.dat, family=neg.bin(theta=1))
summary(uses.nb)
plot(uses.nb)
qqnorm(resid(uses.nb))
qqline(resid(uses.nb))
r2_nakagawa(uses.nb) # Conditional R2 may be under or over estimated

```

#################### Selectivity Index - Site Groups ####################

```{r, SELECTIVITY INDEX - Load data}
# Bring in data sheets
bites <- read.csv("/Users/Kat/Documents/2_Research/Fish Follows Manuscript/GitHub/strauss_food.csv")
benthos <- read.csv("/Users/Kat/Documents/2_Research/Fish Follows Manuscript/GitHub/strauss_benthos.csv")

# Create df by site groupings
bites1 <- bites %>%
   filter(site.id %in% c("L1S1", "L3S1")) # SITE GROUP A

bites2 <- bites %>%
   filter(site.id %in% c("L1S3", "L2S3")) # SITE GROUP B

bites3 <- bites %>%
   filter(site.id %in% c("L1S2", "L2S1", "L2S2", "L3S2", "L3S3")) # SITE GROUP C

benthos1 <- benthos %>%
   filter(site.id %in% c("L1S1", "L3S1")) # SITE GROUP A

benthos2 <- benthos %>%
   filter(site.id %in% c("L1S3", "L2S3")) # SITE GROUP B

benthos3 <- benthos %>%
   filter(site.id %in% c("L1S2", "L2S1", "L2S2", "L3S2", "L3S3")) # SITE GROUP C

```

```{r, SELECTIVITY INDEX, A. triostegus, SITE GROUP A (1)}
# Subset species
at.bites1 <- subset(bites1, species=="A. triostegus")
at.benth1 <- subset(benthos1, species=="A. triostegus")
head(at.bites1)
head(at.benth1)

# Delete columns that won't be analyzed in strauss index
s.bites1 <- at.bites1[c(-1,-2,-3)]
s.benthos1 <- at.benth1[c(-1,-2,-3)]
head(s.bites1)
head(s.benthos1)

# Run strauss index
strauss1 <- (s.bites1-s.benthos1)

# Make the plot
atstrau1 <- cbind(at.bites1[,2], strauss1)
atstra11 <- melt(atstrau1, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


atresstr1 <- summarySE(atstra11, measurevar="strauss", groupvar="Category")
View(atresstr1)

# ggplot
atstrau1.plot <- ggplot(atresstr1, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="A. triostegus - Site 1") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(atstrau1.plot)
#ggsave("atstrau.jpg", atstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, A. triostegus, SITE GROUP B (2)}
# Subset species
at.bites2 <- subset(bites2, species=="A. triostegus")
at.benth2 <- subset(benthos2, species=="A. triostegus")

# Delete columns that won't be analyzed in strauss index
s.bites2 <- at.bites2[c(-1,-2,-3)]
s.benthos2 <- at.benth2[c(-1,-2,-3)]


# Run strauss index
strauss2 <- (s.bites2-s.benthos2)

# Make the plot
atstrau2 <- cbind(at.bites2[,2], strauss2)
atstra12 <- melt(atstrau2, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


atresstr2 <- summarySE(atstra12, measurevar="strauss", groupvar="Category")
View(atresstr2)

# ggplot
atstrau2.plot <- ggplot(atresstr2, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="A. triostegus - Site 2") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(atstrau2.plot)
#ggsave("atstrau.jpg", atstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, A. triostegus, SITE GROUP C (3)}
# Subset species
at.bites3 <- subset(bites3, species=="A. triostegus")
at.benth3 <- subset(benthos3, species=="A. triostegus")

# Delete columns that won't be analyzed in strauss index
s.bites3 <- at.bites3[c(-1,-2,-3)]
s.benthos3 <- at.benth3[c(-1,-2,-3)]


# Run strauss index
strauss3 <- (s.bites3-s.benthos3)

# Make the plot
atstrau3 <- cbind(at.bites3[,2], strauss3)
atstra13 <- melt(atstrau3, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


atresstr3 <- summarySE(atstra13, measurevar="strauss", groupvar="Category")
View(atresstr3)

# ggplot
atstrau3.plot <- ggplot(atresstr3, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="A. triostegus - Site 3") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(atstrau3.plot)
#ggsave("atstrau.jpg", atstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, A. blochii, SITE GROUP A (1)}
# Subset species
ab.bites1 <- subset(bites1, species=="A. blochii")
ab.benth1 <- subset(benthos1, species=="A. blochii")
head(ab.bites1)
head(ab.benth1)

# Delete columns that won't be analyzed in strauss index
abs.bites1 <- ab.bites1[c(-1,-2,-3)]
abs.benthos1 <- ab.benth1[c(-1,-2,-3)]

# Run strauss index
abstrauss1 <- (abs.bites1-abs.benthos1)

# Make the plot
abstrau1 <- cbind(ab.bites1[,2], abstrauss1)
abstra11 <- melt(abstrau1, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


abresstr1 <- summarySE(abstra11, measurevar="strauss", groupvar="Category")V

# ggplot
abstrau1.plot <- ggplot(abresstr1, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="A. blochii - Site 1") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(abstrau1.plot)
#ggsave("abstrau.jpg", abstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, A. blochii, SITE GROUP B (2)}
# Subset species
ab.bites2 <- subset(bites2, species=="A. blochii")
ab.benth2 <- subset(benthos2, species=="A. blochii")
head(ab.bites2)
head(ab.benth2)

# Delete columns that won't be analyzed in strauss index
abs.bites2 <- ab.bites2[c(-1,-2,-3)]
abs.benthos2 <- ab.benth2[c(-1,-2,-3)]

# Run strauss index
abstrauss2 <- (abs.bites2-abs.benthos2)

# Make the plot
abstrau2 <- cbind(ab.bites2[,2], abstrauss2)
abstra12 <- melt(abstrau2, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


abresstr2 <- summarySE(abstra12, measurevar="strauss", groupvar="Category")

# ggplot
abstrau2.plot <- ggplot(abresstr2, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="A. blochii - Site 2") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(abstrau2.plot)
#ggsave("abstrau.jpg", abstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, A. blochii, SITE GROUP C (3)}
# Subset species
ab.bites3 <- subset(bites3, species=="A. blochii")
ab.benth3 <- subset(benthos3, species=="A. blochii")

# Delete columns that won't be analyzed in strauss index
abs.bites3 <- ab.bites3[c(-1,-2,-3)]
abs.benthos3 <- ab.benth3[c(-1,-2,-3)]

# Run strauss index
abstrauss3 <- (abs.bites3-abs.benthos3)

# Make the plot
abstrau3 <- cbind(ab.bites3[,2], abstrauss3)
abstra13 <- melt(abstrau3, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


abresstr3 <- summarySE(abstra13, measurevar="strauss", groupvar="Category")

# ggplot
abstrau3.plot <- ggplot(abresstr3, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="A. blochii - Site 3") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(abstrau3.plot)
#ggsave("abstrau.jpg", abstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, Z. flavescens, SITE GROUP A (1)}
# Subset species
zf.bites1 <- subset(bites1, species=="Z. flavescens")
zf.benth1 <- subset(benthos1, species=="Z. flavescens")

# Delete columns that won't be analyzed in strauss index
zfs.bites1 <- zf.bites1[c(-1,-2,-3)]
zfs.benthos1 <- zf.benth1[c(-1,-2,-3)]

# Run strauss index
zfstrauss1 <- (zfs.bites1-zfs.benthos1)

# Make the plot
zfstrau1 <- cbind(zf.bites1[,2], zfstrauss1)
zfstra11 <- melt(zfstrau1, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


zfresstr1 <- summarySE(zfstra11, measurevar="strauss", groupvar="Category")

# ggplot
zfstrau1.plot <- ggplot(zfresstr1, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="Z. flavescens - Site 1") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(zfstrau1.plot)
#ggsave("zfstrau.jpg", zfstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, Z. flavescens, SITE GROUP B (2)}
# Subset species
zf.bites2 <- subset(bites2, species=="Z. flavescens")
zf.benth2 <- subset(benthos2, species=="Z. flavescens")

# Delete columns that won't be analyzed in strauss index
zfs.bites2 <- zf.bites2[c(-1,-2,-3)]
zfs.benthos2 <- zf.benth2[c(-1,-2,-3)]

# Run strauss index
zfstrauss2 <- (zfs.bites2-zfs.benthos2)

# Make the plot
zfstrau2 <- cbind(zf.bites2[,2], zfstrauss2)
zfstra12 <- melt(zfstrau2, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


zfresstr2 <- summarySE(zfstra12, measurevar="strauss", groupvar="Category")

# ggplot
zfstrau2.plot <- ggplot(zfresstr2, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="Z. flavescens - Site 2") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(zfstrau2.plot)
#ggsave("zfstrau.jpg", zfstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, Z. flavescens, SITE GROUP C (3)}
# Subset species
zf.bites3 <- subset(bites3, species=="Z. flavescens")
zf.benth3 <- subset(benthos3, species=="Z. flavescens")

# Delete columns that won't be analyzed in strauss index
zfs.bites3 <- zf.bites3[c(-1,-2,-3)]
zfs.benthos3 <- zf.benth3[c(-1,-2,-3)]

# Run strauss index
zfstrauss3 <- (zfs.bites3-zfs.benthos3)

# Make the plot
zfstrau3 <- cbind(zf.bites3[,2], zfstrauss3)
zfstra13 <- melt(zfstrau3, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


zfresstr3 <- summarySE(zfstra13, measurevar="strauss", groupvar="Category")

# ggplot
zfstrau3.plot <- ggplot(zfresstr3, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="Z. flavescens - Site 3") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(zfstrau3.plot)
#ggsave("zfstrau.jpg", zfstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, N. unicornis and N. lituratus, SITE GROUP A (1)}
# Subset species
uni.strau <- c("N. unicornis", "N. lituratus")

uni.bites1 <- subset(bites1, species %in% uni.strau)
uni.benth1 <- subset(benthos1, species %in% uni.strau)

# Delete columns that won't be analyzed in strauss index
unis.bites1 <- uni.bites1[c(-1,-2,-3)]
unis.benthos1 <- uni.benth1[c(-1,-2,-3)]

# Run strauss index
unistrauss1 <- (unis.bites1-unis.benthos1)

# Make the plot
unistrau1 <- cbind(uni.bites1[,2], unistrauss1)
unistra11 <- melt(unistrau1, variable.name="Category", value.name = "strauss")
View(unistra11)

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


uniresstr1 <- summarySE(unistra11, measurevar="strauss", groupvar="Category")
View(uniresstr1)

# ggplot
unistrau1.plot <- ggplot(uniresstr1, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="N. unicornis and N. lituratus - Site 1") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(unistrau1.plot)
#ggsave("unistrau.jpg", unistrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, N. unicornis and N. lituratus, SITE GROUP B (2)}
# Subset species
uni.strau <- c("N. unicornis", "N. lituratus")

uni.bites2 <- subset(bites2, species %in% uni.strau)
uni.benth2 <- subset(benthos2, species %in% uni.strau)

# Delete columns that won't be analyzed in strauss index
unis.bites2 <- uni.bites2[c(-1,-2,-3)]
unis.benthos2 <- uni.benth2[c(-1,-2,-3)]

# Run strauss index
unistrauss2 <- (unis.bites2-unis.benthos2)

# Make the plot
unistrau2 <- cbind(uni.bites2[,2], unistrauss2)
unistra12 <- melt(unistrau2, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}

# NO UNIS OBSERVED IN SITE GROUP B. Manually input 0s to previously built table
uniresstr2 <- summarySE(unistra12, measurevar="strauss", groupvar="Category")

# Manually input 0s
uniresstr2.0 <- uniresstr2 %>%
  mutate(N = 0,
         mean = 0,
         sd = 0,
         sum = 0,
         median = 0,
         max = 0,
         min = 0,
         se = 0,
         ci = 0)

# ggplot
unistrau2.plot <- ggplot(uniresstr2.0, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="N. unicornis and N. lituratus - Site 2") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(unistrau2.plot)
#ggsave("unistrau.jpg", unistrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, N. unicornis and N. lituratus, SITE GROUP C (3)}
# Subset species
uni.strau <- c("N. unicornis", "N. lituratus")

uni.bites3 <- subset(bites3, species %in% uni.strau)
uni.benth3 <- subset(benthos3, species %in% uni.strau)

# Delete columns that won't be analyzed in strauss index
unis.bites3 <- uni.bites3[c(-1,-2,-3)]
unis.benthos3 <- uni.benth3[c(-1,-2,-3)]

# Run strauss index
unistrauss3 <- (unis.bites3-unis.benthos3)

# Make the plot
unistrau3 <- cbind(uni.bites3[,2], unistrauss3)
unistra13 <- melt(unistrau3, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


uniresstr3 <- summarySE(unistra13, measurevar="strauss", groupvar="Category")

# ggplot
unistrau3.plot <- ggplot(uniresstr3, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="N. unicornis and N. lituratus - Site 3") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(unistrau3.plot)
#ggsave("unistrau.jpg", unistrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, Z. velifer, SITE GROUP A (1)}
# Subset species
zv.bites1 <- subset(bites1, species=="Z. velifer")
zv.benth1 <- subset(benthos1, species=="Z. velifer")

# Delete columns that won't be analyzed in strauss index
zvs.bites1 <- zv.bites1[c(-1,-2,-3)]
zvs.benthos1 <- zv.benth1[c(-1,-2,-3)]

# Run strauss index
zvstrauss1 <- (zvs.bites1-zvs.benthos1)

# Make the plot
zvstrau1 <- cbind(zv.bites1[,2], zvstrauss1)
zvstra11 <- melt(zvstrau1, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


zvresstr1 <- summarySE(zvstra11, measurevar="strauss", groupvar="Category")

# ggplot
zvstrau1.plot <- ggplot(zvresstr1, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="Z. velifer - Site 1") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(zvstrau1.plot)
#ggsave("zvstrau.jpg", zvstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, Z. velifer, SITE GROUP B (2)}
# Subset species
zv.bites2 <- subset(bites2, species=="Z. velifer")
zv.benth2 <- subset(benthos2, species=="Z. velifer")

# Delete columns that won't be analyzed in strauss index
zvs.bites2 <- zv.bites2[c(-1,-2,-3)]
zvs.benthos2 <- zv.benth2[c(-1,-2,-3)]

# Run strauss index
zvstrauss2 <- (zvs.bites2-zvs.benthos2)

# Make the plot
zvstrau2 <- cbind(zv.bites2[,2], zvstrauss2)
zvstra12 <- melt(zvstrau2, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


zvresstr2 <- summarySE(zvstra12, measurevar="strauss", groupvar="Category")

# ggplot
zvstrau2.plot <- ggplot(zvresstr2, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="Z. velifer - Site 2") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(zvstrau2.plot)
#ggsave("zvstrau.jpg", zvstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, Z. velifer, SITE GROUP C (3)}
# Subset species
zv.bites3 <- subset(bites3, species=="Z. velifer")
zv.benth3 <- subset(benthos3, species=="Z. velifer")

# Delete columns that won't be analyzed in strauss index
zvs.bites3 <- zv.bites3[c(-1,-2,-3)]
zvs.benthos3 <- zv.benth3[c(-1,-2,-3)]

# Run strauss index
zvstrauss3 <- (zvs.bites3-zvs.benthos3)

# Make the plot
zvstrau3 <- cbind(zv.bites3[,2], zvstrauss3)
zvstra13 <- melt(zvstrau3, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


zvresstr3 <- summarySE(zvstra13, measurevar="strauss", groupvar="Category")

# ggplot
zvstrau3.plot <- ggplot(zvresstr3, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="Z. velifer - Site 3") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(zvstrau3.plot)
#ggsave("zvstrau.jpg", zvstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, C. spilurus, SITE GROUP A (1)}
# Subset species
cs.bites1 <- subset(bites1, species=="C. spilurus ")
cs.benth1 <- subset(benthos1, species=="C. spilurus ")

# Delete columns that won't be analyzed in strauss index
css.bites1 <- cs.bites1[c(-1,-2,-3)]
css.benthos1 <- cs.benth1[c(-1,-2,-3)]

# Run strauss index
csstrauss1 <- (css.bites1-css.benthos1)

# Make the plot
csstrau1 <- cbind(cs.bites1[,2], csstrauss1)
csstra11 <- melt(csstrau1, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


csresstr1 <- summarySE(csstra11, measurevar="strauss", groupvar="Category")

# ggplot
csstrau1.plot <- ggplot(csresstr1, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="C. spilurus - Site 1") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(csstrau1.plot)
#ggsave("csstrau.jpg", csstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, C. spilurus, SITE GROUP B (2)}
# Subset species
cs.bites2 <- subset(bites2, species=="C. spilurus ")
cs.benth2 <- subset(benthos2, species=="C. spilurus ")

# Delete columns that won't be analyzed in strauss index
css.bites2 <- cs.bites2[c(-1,-2,-3)]
css.benthos2 <- cs.benth2[c(-1,-2,-3)]

# Run strauss index
csstrauss2 <- (css.bites2-css.benthos2)

# Make the plot
csstrau2 <- cbind(cs.bites2[,2], csstrauss2)
csstra12 <- melt(csstrau2, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


csresstr2 <- summarySE(csstra12, measurevar="strauss", groupvar="Category")

# ggplot
csstrau2.plot <- ggplot(csresstr2, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="C. spilurus - Site 2") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(csstrau2.plot)
#ggsave("csstrau.jpg", csstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, C. spilurus, SITE GROUP C (3)}
# Subset species
cs.bites3 <- subset(bites3, species=="C. spilurus ")
cs.benth3 <- subset(benthos3, species=="C. spilurus ")

# Delete columns that won't be analyzed in strauss index
css.bites3 <- cs.bites3[c(-1,-2,-3)]
css.benthos3 <- cs.benth3[c(-1,-2,-3)]

# Run strauss index
csstrauss3 <- (css.bites3-css.benthos3)

# Make the plot
csstrau3 <- cbind(cs.bites3[,2], csstrauss3)
csstra13 <- melt(csstrau3, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


csresstr3 <- summarySE(csstra13, measurevar="strauss", groupvar="Category")

# ggplot
csstrau3.plot <- ggplot(csresstr3, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="C. spilurus - Site 3") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(csstrau3.plot)
#ggsave("csstrau.jpg", csstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, S. psittacus, SITE GROUP A (1)}
# Subset species
sp.bites1 <- subset(bites1, species=="S. psittacus")
sp.benth1 <- subset(benthos1, species=="S. psittacus")

# Delete columns that won't be analyzed in strauss index
sps.bites1 <- sp.bites1[c(-1,-2,-3)]
sps.benthos1 <- sp.benth1[c(-1,-2,-3)]

# Run strauss index
spstrauss1 <- (sps.bites1-sps.benthos1)

# Make the plot
spstrau1 <- cbind(sp.bites1[,2], spstrauss1)
spstra11 <- melt(spstrau1, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


spresstr1 <- summarySE(spstra11, measurevar="strauss", groupvar="Category")

# ggplot
spstrau1.plot <- ggplot(spresstr1, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) + #keep 
  geom_point(position=position_dodge(0.5)) + 
  geom_hline(yintercept=0, linetype="dotted") + # keep
  ylim(-1,1) + # keep
  ylab("Mean") +
  xlab("Category") +
  labs(title="S. psittacus - Site 1") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(spstrau1.plot)
#ggsave("spstrau.jpg", spstrau.plot, width=6, height=4, dpi=300)


```

```{r, SELECTIVITY INDEX, S. psittacus, SITE GROUP B (2)}
# Subset species
sp.bites2 <- subset(bites2, species=="S. psittacus")
sp.benth2 <- subset(benthos2, species=="S. psittacus")

# Delete columns that won't be analyzed in strauss index
sps.bites2 <- sp.bites2[c(-1,-2,-3)]
sps.benthos2 <- sp.benth2[c(-1,-2,-3)]

# Run strauss index
spstrauss2 <- (sps.bites2-sps.benthos2)

# Make the plot
spstrau2 <- cbind(sp.bites2[,2], spstrauss2)
spstra12 <- melt(spstrau2, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


spresstr2 <- summarySE(spstra12, measurevar="strauss", groupvar="Category")

# ggplot
spstrau2.plot <- ggplot(spresstr2, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) + #keep 
  geom_point(position=position_dodge(0.5)) + 
  geom_hline(yintercept=0, linetype="dotted") + # keep
  ylim(-1,1) + # keep
  ylab("Mean") +
  xlab("Category") +
  labs(title="S. psittacus - Site 2") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(spstrau2.plot)
#ggsave("spstrau.jpg", spstrau.plot, width=6, height=4, dpi=300)


```

```{r, SELECTIVITY INDEX, S. psittacus, SITE GRUOP C (3)}
# Subset species
sp.bites3 <- subset(bites3, species=="S. psittacus")
sp.benth3 <- subset(benthos3, species=="S. psittacus")

# Delete columns that won't be analyzed in strauss index
sps.bites3 <- sp.bites3[c(-1,-2,-3)]
sps.benthos3 <- sp.benth3[c(-1,-2,-3)]

# Run strauss index
spstrauss3 <- (sps.bites3-sps.benthos3)

# Make the plot
spstrau3 <- cbind(sp.bites3[,2], spstrauss3)
spstra13 <- melt(spstrau3, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


spresstr3 <- summarySE(spstra13, measurevar="strauss", groupvar="Category")

# ggplot
spstrau3.plot <- ggplot(spresstr3, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) + #keep 
  geom_point(position=position_dodge(0.5)) + 
  geom_hline(yintercept=0, linetype="dotted") + # keep
  ylim(-1,1) + # keep
  ylab("Mean") +
  xlab("Category") +
  labs(title="S. psittacus - Site 3") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(spstrau3.plot)
#ggsave("spstrau.jpg", spstrau.plot, width=6, height=4, dpi=300)

```

```{r, PLOT - SELECTIVITY INDEX BARGRAPH}

# Build dataframe

abresstr1$species <- 'A. blochii'
atresstr1$species <- 'A. triostegus'
zfresstr1$species <- 'Z. flavescens'
zvresstr1$species <- 'Z. velifer'
uniresstr1$species <- 'Naso spp.'
csresstr1$species <- 'C. spilurus'
spresstr1$species <- 'S. psittacus'

abresstr2$species <- 'A. blochii'
atresstr2$species <- 'A. triostegus'
zfresstr2$species <- 'Z. flavescens'
zvresstr2$species <- 'Z. velifer'
uniresstr2$species <- 'Naso spp.'
csresstr2$species <- 'C. spilurus'
spresstr2$species <- 'S. psittacus'

abresstr3$species <- 'A. blochii'
atresstr3$species <- 'A. triostegus'
zfresstr3$species <- 'Z. flavescens'
zvresstr3$species <- 'Z. velifer'
uniresstr3$species <- 'Naso spp.'
csresstr3$species <- 'C. spilurus'
spresstr3$species <- 'S. psittacus'

abresstr1$site <- '1' # Site Group A - high turbidity
atresstr1$site <- '1'
zfresstr1$site <- '1'
zvresstr1$site <- '1'
uniresstr1$site <- '1'
csresstr1$site <- '1'
spresstr1$site <- '1'

abresstr2$site <- '2' # Site Group B - medium turbidity
atresstr2$site <- '2'
zfresstr2$site <- '2'
zvresstr2$site <- '2'
uniresstr2$site <- '2'
csresstr2$site <- '2'
spresstr2$site <- '2'

abresstr3$site <- '3' # SIte Group C - low turbidity
atresstr3$site <- '3'
zfresstr3$site <- '3'
zvresstr3$site <- '3'
uniresstr3$site <- '3'
csresstr3$site <- '3'
spresstr3$site <- '3'

ncol(abresstr1)
ncol(atresstr1)
ncol(zfresstr1)
ncol(zvresstr1)
ncol(csresstr1)
ncol(spresstr1)
ncol(uniresstr1)
ncol(abresstr2)
ncol(atresstr2)
ncol(zfresstr2)
ncol(zvresstr2)
ncol(csresstr2)
ncol(spresstr2)
ncol(uniresstr2)
ncol(abresstr3)
ncol(atresstr3)
ncol(zfresstr3)
ncol(zvresstr3)
ncol(csresstr3)
ncol(spresstr3)
ncol(uniresstr3)

selectsite.dat <- rbind(abresstr1, atresstr1, zfresstr1, zvresstr1, uniresstr1, csresstr1, spresstr1, abresstr2, atresstr2, zfresstr2, zvresstr2, uniresstr2.0, csresstr2, spresstr2, abresstr3, atresstr3, zfresstr3, zvresstr3, uniresstr3, csresstr3, spresstr3)
View(selectsite.dat)

# Build barplot and flip coordinates
order.selgroup <- c("S. psittacus", "C. spilurus", "N. lituratus & N. unicornis", "Z. velifer","Z. flavescens", "A. triostegus", "A. blochii")
selectsite.dat$species <- factor(select.dat$species, levels = order.selgroup)
View(selectsite.dat)

# SITE GROUP A - HIGH TURBIDITY #
select1.plot <- ggplot(subset(selectsite.dat, site == "1"), aes(x=as.factor(Category), y=mean, fill=species)) +
   geom_bar(position="dodge", stat="identity", color="black", linewidth=0.3) + 
    geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci, group=species),  width=0.3,position=position_dodge(0.9)) + #
   geom_hline(yintercept=0, linetype="dotted") + 
  coord_flip() +
  ylab("Selectivity") +
  xlab("") +
  ylim(-1,1) +
  labs(fill = "Species", title="High") +
  scale_x_discrete(labels=c("Other", "Rock", "Rubble", "Sponge", "CCA", "Coral", "Macro", "Turf"), limits = rev(levels(select.dat$Category))) +
  theme(axis.line.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        plot.background = element_rect(fill = "#B5885A"),
        legend.text = element_text(face = "italic")) +
    scale_fill_fish_d(option = "Cirrhilabrus_solorensis", guide=guide_legend(reverse = TRUE), labels=c("S. psittacus", "C. spilurus", "Naso spp.^", "Z. velifer", "Z. flavescens^ ", "A. triostegus", "A. blochii"))
print(select1.plot)

# SITE GROUP B - MEDIUM TURBIDITY #
select2.plot <- ggplot(subset(selectsite.dat, site == "2"), aes(x=as.factor(Category), y=mean, fill=species)) +
   geom_bar(position="dodge", stat="identity", color="black", linewidth=0.3) + 
    geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci, group=species),  width=0.3,position=position_dodge(0.9)) + #
   geom_hline(yintercept=0, linetype="dotted") + 
  coord_flip() +
  ylab("Selectivity") +
  xlab("") +
  ylim(-1,1) +
  labs(fill = "Species", title="Medium") +
  scale_x_discrete(labels=c("Other", "Rock", "Rubble", "Sponge", "CCA", "Coral", "Macro", "Turf"), limits = rev(levels(select.dat$Category))) +
    scale_fill_fish_d(option = "Cirrhilabrus_solorensis", guide=guide_legend(reverse = TRUE), labels=c("S. psittacus", "C. spilurus", "Naso spp.^", "Z. velifer", "Z. flavescens ^", "A. triostegus", "A. blochii")) +
    theme(axis.line.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        plot.background = element_rect(fill = "#D2B48C"), legend.text = element_text(face = "italic"))
print(select2.plot)

# SITE GROUP C - Low Turbidity (Control) #
select3.plot <- ggplot(subset(selectsite.dat, site == "3"), aes(x=as.factor(Category), y=mean, fill=species)) +
   geom_bar(position="dodge", stat="identity", color="black", linewidth=0.3) + 
    geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci, group=species),  width=0.3,position=position_dodge(0.9)) + #
   geom_hline(yintercept=0, linetype="dotted") + 
  coord_flip() +
  ylab("Selectivity") +
  xlab("") +
  ylim(-1,1) +
  labs(fill = "Species", title="Low") +
  scale_x_discrete(labels=c("Other", "Rock", "Rubble", "Sponge", "CCA", "Coral", "Macro", "Turf"), limits = rev(levels(select.dat$Category))) +
    scale_fill_fish_d(option = "Cirrhilabrus_solorensis", guide=guide_legend(reverse = TRUE), labels=c("S. psittacus", "C. spilurus", "Naso spp.^", "Z. velifer", "Z. flavescens^ ", "A. triostegus", "A. blochii")) +
  theme(plot.background = element_rect(fill = "#F5F5DC"), legend.text = element_text(face = "italic"))
    #annotation_raster(rock.img, xmin = 1.8, xmax = 2.2, ymin = -1.0, ymax = -0.7) +
  #annotation_raster(rubble.img, xmin = 2.8, xmax = 3.2, ymin = -1.0, ymax = -0.7) +
  #annotation_raster(sponge.img, xmin = 3.5, xmax = 4.4, ymin = -1.0, ymax = -0.7) +
  #annotation_raster(cca.img, xmin = 4.9, xmax = 5.1, ymin = -1.0, ymax = -0.7) +
  #annotation_raster(coral.img, xmin = 5.7, xmax = 6.2, ymin = -1.0, ymax = -0.7) +
  #annotation_raster(macro.img, xmin = 6.8, xmax = 7.2, ymin = -1.0, ymax = -0.7) +
  #annotation_raster(turf.img, xmin = 8.0, xmax = 8.2, ymin = -1.0, ymax = -0.7)
print(select3.plot)

selectsite.plot <- ggarrange(select3.plot,select2.plot,select1.plot, common.legend = TRUE, legend = "right", ncol =3 , nrow = 1)
#print(selectsite.plot)
#ggsave("selectsite.plot.jpg", selectsite.plot, width=11, height=7, dpi=300)


```

```{r, ANOVA for Selectivity Index - Site Groups}
### Can't run with Naso spp. or Z. flavescens because sample sizes don't work ###

### A. blochii ###
# Add columns
abstra11$group <- "A"
abstra12$group <- "B"
abstra13$group  <- "C"
# Check column names to match
names(abstra11)
names(abstra12)
names(abstra13)
# Change name to match
newabstra12 <- abstra12
newabstra13 <- abstra13
names(newabstra12)[names(newabstra12) == "ab.bites2[, 2]"] <- "ab.bites1[, 2]"
names(newabstra13)[names(newabstra13) == "ab.bites3[, 2]"] <- "ab.bites1[, 2]"
# Now combine
ab.gbind <- rbind(abstra11, newabstra12, newabstra13)

# Subset the data to include only rows where 'category' is equal to 'turf'
ab.gsub <- ab.gbind[ab.gbind$Category == "turf", ] # CHANGE FOOD CHOICE HERE

# Run ANOVA and post-hoc Tukey test
abgroup.aov <- aov(strauss~group, ab.gsub)
summary(abgroup.aov)
TukeyHSD(abgroup.aov)

### A. triostegus ###
# Add columns
atstra11$group <- "A"
atstra12$group <- "B"
atstra13$group  <- "C"
# Check column names to match
names(atstra11)
names(atstra12)
names(atstra13)
# Change name to match
newatstra12 <- atstra12
newatstra13 <- atstra13
names(newatstra12)[names(newatstra12) == "at.bites2[, 2]"] <- "at.bites1[, 2]"
names(newatstra13)[names(newatstra13) == "at.bites3[, 2]"] <- "at.bites1[, 2]"
# Now combine
at.gbind <- rbind(atstra11, newatstra12, newatstra13)

# Subset the data to include only rows where 'category' is equal to 'turf'
at.gsub <- at.gbind[at.gbind$Category == "macro", ] # CHANGE FOOD CHOICE HERE

# Run ANOVA and post-hoc Tukey test
atgroup.aov <- aov(strauss~group, at.gsub)
summary(atgroup.aov)
TukeyHSD(atgroup.aov)

### Z. velifer ###
# Add columns
zvstra11$group <- "A"
zvstra12$group <- "B"
zvstra13$group  <- "C"
# Check column names to match
names(zvstra11)
names(zvstra12)
names(zvstra13)
# Change name to match
newzvstra12 <- zvstra12
newzvstra13 <- zvstra13
names(newzvstra12)[names(newzvstra12) == "zv.bites2[, 2]"] <- "zv.bites1[, 2]"
names(newzvstra13)[names(newzvstra13) == "zv.bites3[, 2]"] <- "zv.bites1[, 2]"
# Now combine
zv.gbind <- rbind(zvstra11, newzvstra12, newzvstra13)

# Subset the data to include only rows where 'category' is equal to 'turf'
zv.gsub <- zv.gbind[zv.gbind$Category == "macro", ] # CHANGE FOOD CHOICE HERE

# Run ANOVA and post-hoc Tukey test
zvgroup.aov <- aov(strauss~group, zv.gsub)
summary(zvgroup.aov)
TukeyHSD(zvgroup.aov)


### C. spilurus ###
# Add columns
csstra11$group <- "A"
csstra12$group <- "B"
csstra13$group  <- "C"
# Check column names to match
names(csstra11)
names(csstra12)
names(csstra13)
# Change name to match
newcsstra12 <- csstra12
newcsstra13 <- csstra13
names(newcsstra12)[names(newcsstra12) == "cs.bites2[, 2]"] <- "cs.bites1[, 2]"
names(newcsstra13)[names(newcsstra13) == "cs.bites3[, 2]"] <- "cs.bites1[, 2]"
# Now combine
cs.gbind <- rbind(csstra11, newcsstra12, newcsstra13)

# Subset the data to include only rows where 'category' is equal to 'turf'
cs.gsub <- cs.gbind[cs.gbind$Category == "macro", ] # CHANGE FOOD CHOICE HERE

# Run ANOVA and post-hoc Tukey test
csgroup.aov <- aov(strauss~group, cs.gsub)
summary(csgroup.aov)
TukeyHSD(csgroup.aov)

### S. psittaucs ###
# Add columns
spstra11$group <- "A"
spstra12$group <- "B"
spstra13$group  <- "C"
# Check column names to match
names(spstra11)
names(spstra12)
names(spstra13)
# Change name to match
newspstra12 <- spstra12
newspstra13 <- spstra13
names(newspstra12)[names(newspstra12) == "sp.bites2[, 2]"] <- "sp.bites1[, 2]"
names(newspstra13)[names(newspstra13) == "sp.bites3[, 2]"] <- "sp.bites1[, 2]"
# Now combine
sp.gbind <- rbind(spstra11, newspstra12, newspstra13)

# Subset the data to include only rows where 'category' is equal to 'turf'
sp.gsub <- sp.gbind[sp.gbind$Category == "turf", ] # CHANGE FOOD CHOICE HERE

# Run ANOVA and post-hoc Tukey test
spgroup.aov <- aov(strauss~group, sp.gsub)
summary(spgroup.aov)
TukeyHSD(spgroup.aov)


```
  
#################### Selectivity Index - SeS vs. No SeS ####################  
  
```{r, SELECTIVITY INDEX, SeS DATA WRANGLING}  
sesbites <- read.csv("/Users/Kat/Documents/2_Research/Thesis Resources/Fish Follows Manuscript/GitHub/strauss_food_ses.csv")
sesbenthos <- read.csv("/Users/Kat/Documents/2_Research/Thesis Resources/Fish Follows Manuscript/GitHub/strauss_benthos_ses.csv")

# Remove surveys without SeS observation and split data frames
sesbites1 <- sesbites %>%
  filter(ses != "-")
sesbenthos <- sesbenthos %>%
  filter(ses != "-")

# Split dataset
sesbites1 <- sesbites %>%
  filter(ses == "Y")
sesbenthos1 <- sesbenthos %>%
  filter(ses == "Y")
nrow(sesbites1) #1516
nrow(sesbenthos1) #1516

sesbites0 <- sesbites %>%
  filter(ses == "")
sesbenthos0 <- sesbenthos %>%
  filter(ses == "")
nrow(sesbites0) # 966
nrow(sesbenthos0) #966

```

```{r, SELECTIVITY INDEX, A. triostegus, SeS 1}
# Subset species
at.bites1ses <- subset(sesbites1, species=="A. triostegus")
at.benth1ses <- subset(sesbenthos1, species=="A. triostegus")


# Delete columns that won't be analyzed in strauss index
s.bites1ses <- at.bites1ses[c(-1,-2,-3,-12)]
s.benthos1ses <- at.benth1ses[c(-1,-2,-3,-12)]

# Run strauss index
strauss1ses <- (s.bites1ses-s.benthos1ses)

# Make the plot
atstrau1ses <- cbind(at.bites1ses[,2], strauss1ses)
atstra11ses <- melt(atstrau1ses, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


atresstr1ses <- summarySE(atstra11ses, measurevar="strauss", groupvar="Category")

# ggplot
atstrau1ses.plot <- ggplot(atresstr1ses, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="A. triostegus - SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(atstrau1ses.plot)
#ggsave("atstrau.jpg", atstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, A. triostegus, No SeS 0}
# Subset species
at.bites0 <- subset(sesbites0, species=="A. triostegus")
at.benth0 <- subset(sesbenthos0, species=="A. triostegus")


# Delete columns that won't be analyzed in strauss index
s.bites0 <- at.bites0[c(-1,-2,-3,-12)]
s.benthos0 <- at.benth0[c(-1,-2,-3,-12)]

# Run strauss index
strauss0 <- (s.bites0-s.benthos0)

# Make the plot
atstrau0 <- cbind(at.bites0[,2], strauss0)
atstra10 <- melt(atstrau0, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


atresstr0 <- summarySE(atstra10, measurevar="strauss", groupvar="Category")

# ggplot
atstrau0.plot <- ggplot(atresstr0, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="A. triostegus - No SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(atstrau0.plot)
#ggsave("atstrau.jpg", atstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, A. blochii, SeS 1}
# Subset species
ab.bites1ses <- subset(sesbites1, species=="A. blochii")
ab.benth1ses <- subset(sesbenthos1, species=="A. blochii")


# Delete columns that won't be analyzed in strauss index
abs.bites1ses <- ab.bites1ses[c(-1,-2,-3,-12)]
abs.benthos1ses <- ab.benth1ses[c(-1,-2,-3,-12)]

# Run strauss index
abstrauss1ses <- (abs.bites1ses-abs.benthos1ses)

# Make the plot
abstrau1ses <- cbind(ab.bites1ses[,2], abstrauss1ses)
abstra11ses <- melt(abstrau1ses, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


abresstr1ses <- summarySE(abstra11ses, measurevar="strauss", groupvar="Category")

# ggplot
abstrau1ses.plot <- ggplot(abresstr1ses, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="A. blochii - SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(abstrau1ses.plot)
#ggsave("abstrau.jpg", abstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, A. blochii, No SeS 0}
# Subset species
ab.bites0 <- subset(sesbites0, species=="A. blochii")
ab.benth0 <- subset(sesbenthos0, species=="A. blochii")


# Delete columns that won't be analyzed in strauss index
abs.bites0 <- ab.bites0[c(-1,-2,-3,-12)]
abs.benthos0 <- ab.benth0[c(-1,-2,-3,-12)]

# Run strauss index
abstrauss0 <- (abs.bites0-abs.benthos0)

# Make the plot
abstrau0 <- cbind(ab.bites0[,2], abstrauss0)
abstra10 <- melt(abstrau0, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


abresstr0 <- summarySE(abstra10, measurevar="strauss", groupvar="Category")

# ggplot
abstrau0.plot <- ggplot(abresstr0, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="A. blochii - No SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(abstrau0.plot)
#ggsave("abstrau.jpg", abstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, Z. flavescens, SeS 1}
# Subset species
zf.bites1ses <- subset(sesbites1, species=="Z. flavescens")
zf.benth1ses <- subset(sesbenthos1, species=="Z. flavescens")

# Delete columns that won't be analyzed in strauss index
zfs.bites1ses <- zf.bites1ses[c(-1,-2,-3,-12)]
zfs.benthos1ses <- zf.benth1ses[c(-1,-2,-3,-12)]

# Run strauss index
zfstrauss1ses <- (zfs.bites1ses-zfs.benthos1ses)

# Make the plot
zfstrau1ses <- cbind(zf.bites1ses[,2], zfstrauss1ses)
zfstra11ses <- melt(zfstrau1ses, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


zfresstr1ses <- summarySE(zfstra11ses, measurevar="strauss", groupvar="Category")

# ggplot
zfstrau1ses.plot <- ggplot(zfresstr1ses, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="Z. flavescens - SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(zfstrau1ses.plot)
#ggsave("zfstrau.jpg", zfstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, Z. flavescens, No SeS 0}
# Subset species
zf.bites0 <- subset(sesbites0, species=="Z. flavescens")
zf.benth0 <- subset(sesbenthos0, species=="Z. flavescens")

# Delete columns that won't be analyzed in strauss index
zfs.bites0 <- zf.bites0[c(-1,-2,-3,-12)]
zfs.benthos0 <- zf.benth0[c(-1,-2,-3,-12)]

# Run strauss index
zfstrauss0 <- (zfs.bites0-zfs.benthos0)

# Make the plot
zfstrau0 <- cbind(zf.bites0[,2], zfstrauss0)
zfstra10 <- melt(zfstrau0, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


zfresstr0 <- summarySE(zfstra10, measurevar="strauss", groupvar="Category")

# ggplot
zfstrau0.plot <- ggplot(zfresstr0, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="Z. flavescens - No SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(zfstrau0.plot)
#ggsave("zfstrau.jpg", zfstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, N. unicornis and N. lituratus, SeS 1}
# Subset species
uni.strau <- c("N. unicornis", "N. lituratus")

uni.bites1ses <- subset(sesbites1, species %in% uni.strau)
uni.benth1ses <- subset(sesbenthos1, species %in% uni.strau)

# Delete columns that won't be analyzed in strauss index
unis.bites1ses <- uni.bites1ses[c(-1,-2,-3,-12)]
unis.benthos1ses <- uni.benth1ses[c(-1,-2,-3,-12)]

# Run strauss index
unistrauss1ses <- (unis.bites1ses-unis.benthos1ses)

# Make the plot
unistrau1ses <- cbind(uni.bites1ses[,2], unistrauss1ses)
unistra11ses <- melt(unistrau1ses, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


uniresstr1ses <- summarySE(unistra11ses, measurevar="strauss", groupvar="Category")

# ggplot
unistrau1ses.plot <- ggplot(uniresstr1ses, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="N. unicornis and N. lituratus - SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(unistrau1ses.plot)
#ggsave("unistrau.jpg", unistrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, N. unicornis and N. lituratus, No SeS 0}
# Subset species
uni.strau <- c("N. unicornis", "N. lituratus")

uni.bites0 <- subset(sesbites0, species %in% uni.strau)
uni.benth0 <- subset(sesbenthos0, species %in% uni.strau)

# Delete columns that won't be analyzed in strauss index
unis.bites0 <- uni.bites0[c(-1,-2,-3,-12)]
unis.benthos0 <- uni.benth0[c(-1,-2,-3,-12)]

# Run strauss index
unistrauss0 <- (unis.bites0-unis.benthos0)

# Make the plot
unistrau0 <- cbind(uni.bites0[,2], unistrauss0)
unistra10 <- melt(unistrau0, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


uniresstr0 <- summarySE(unistra10, measurevar="strauss", groupvar="Category")

# ggplot
unistrau0.plot <- ggplot(uniresstr0, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="N. unicornis and N. lituratus - No SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(unistrau0.plot)
#ggsave("unistrau.jpg", unistrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, Z. velifer, SeS 1}
# Subset species
zv.bites1ses <- subset(sesbites1, species=="Z. velifer")
zv.benth1ses <- subset(sesbenthos1, species=="Z. velifer")

# Delete columns that won't be analyzed in strauss index
zvs.bites1ses <- zv.bites1ses[c(-1,-2,-3,-12)]
zvs.benthos1ses <- zv.benth1ses[c(-1,-2,-3,-12)]

# Run strauss index
zvstrauss1ses <- (zvs.bites1ses-zvs.benthos1ses)

# Make the plot
zvstrau1ses <- cbind(zv.bites1ses[,2], zvstrauss1ses)
zvstra11ses <- melt(zvstrau1ses, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


zvresstr1ses <- summarySE(zvstra11ses, measurevar="strauss", groupvar="Category")


# ggplot
zvstrau1ses.plot <- ggplot(zvresstr1ses, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="Z. velifer - SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(zvstrau1ses.plot)
#ggsave("zvstrau.jpg", zvstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, Z. velifer, No SeS 0}
# Subset species
zv.bites0 <- subset(sesbites0, species=="Z. velifer")
zv.benth0 <- subset(sesbenthos0, species=="Z. velifer")

# Delete columns that won't be analyzed in strauss index
zvs.bites0 <- zv.bites0[c(-1,-2,-3,-12)]
zvs.benthos0 <- zv.benth0[c(-1,-2,-3,-12)]

# Run strauss index
zvstrauss0 <- (zvs.bites0-zvs.benthos0)

# Make the plot
zvstrau0 <- cbind(zv.bites0[,2], zvstrauss0)
zvstra10 <- melt(zvstrau0, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


zvresstr0 <- summarySE(zvstra10, measurevar="strauss", groupvar="Category")


# ggplot
zvstrau0.plot <- ggplot(zvresstr0, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="Z. velifer - No SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(zvstrau0.plot)
#ggsave("zvstrau.jpg", zvstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, C. spilurus, SeS 1}
# Subset species
cs.bites1ses <- subset(sesbites1, species=="C. spilurus ")
cs.benth1ses <- subset(sesbenthos1, species=="C. spilurus ")

# Delete columns that won't be analyzed in strauss index
css.bites1ses <- cs.bites1ses[c(-1,-2,-3,-12)]
css.benthos1ses <- cs.benth1ses[c(-1,-2,-3,-12)]

# Run strauss index
csstrauss1ses <- (css.bites1ses-css.benthos1ses)

# Make the plot
csstrau1ses <- cbind(cs.bites1ses[,2], csstrauss1ses)
csstra11ses <- melt(csstrau1ses, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


csresstr1ses <- summarySE(csstra11ses, measurevar="strauss", groupvar="Category")

# ggplot
csstrau1ses.plot <- ggplot(csresstr1ses, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="C. spilurus - SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(csstrau1ses.plot)
#ggsave("csstrau.jpg", csstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, C. spilurus, No SeS 0}
# Subset species
cs.bites0 <- subset(sesbites0, species=="C. spilurus ")
cs.benth0 <- subset(sesbenthos0, species=="C. spilurus ")

# Delete columns that won't be analyzed in strauss index
css.bites0 <- cs.bites0[c(-1,-2,-3,-12)]
css.benthos0 <- cs.benth0[c(-1,-2,-3,-12)]

# Run strauss index
csstrauss0 <- (css.bites0-css.benthos0)

# Make the plot
csstrau0 <- cbind(cs.bites0[,2], csstrauss0)
csstra10 <- melt(csstrau0, variable.name="Category", value.name = "strauss")

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


csresstr0 <- summarySE(csstra10, measurevar="strauss", groupvar="Category")
View(csresstr0)

# ggplot
csstrau0.plot <- ggplot(csresstr0, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) +
  geom_point(position=position_dodge(0.5)) +
  geom_hline(yintercept=0, linetype="dotted") +
  ylim(-1,1) +
  ylab("Mean") +
  xlab("Category") +
  labs(title="C. spilurus - No SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(csstrau0.plot)
#ggsave("csstrau.jpg", csstrau.plot, width=6, height=4, dpi=300)

```

```{r, SELECTIVITY INDEX, S. psittacus, SeS 1}
# Subset species
sp.bites1ses <- subset(sesbites1, species=="S. psittacus")
sp.benth1ses <- subset(sesbenthos1, species=="S. psittacus")

# Delete columns that won't be analyzed in strauss index
sps.bites1ses <- sp.bites1ses[c(-1,-2,-3,-12)]
sps.benthos1ses <- sp.benth1ses[c(-1,-2,-3,-12)]

# Run strauss index
spstrauss1ses <- (sps.bites1ses-sps.benthos1ses)

# Make the plot
spstrau1ses <- cbind(sp.bites1ses[,2], spstrauss1ses)
spstra11ses <- melt(spstrau1ses, variable.name="Category", value.name = "strauss")
View(spstra11ses)

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


spresstr1ses <- summarySE(spstra11ses, measurevar="strauss", groupvar="Category")

# ggplot
spstrau1ses.plot <- ggplot(spresstr1ses, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) + #keep 
  geom_point(position=position_dodge(0.5)) + 
  geom_hline(yintercept=0, linetype="dotted") + # keep
  ylim(-1,1) + # keep
  ylab("Mean") +
  xlab("Category") +
  labs(title="S. psittacus - SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(spstrau1ses.plot)
#ggsave("spstrau.jpg", spstrau.plot, width=6, height=4, dpi=300)


```

```{r, SELECTIVITY INDEX, S. psittacus, No SeS 0}
# Subset species
sp.bites0 <- subset(sesbites0, species=="S. psittacus")
sp.benth0 <- subset(sesbenthos0, species=="S. psittacus")

# Delete columns that won't be analyzed in strauss index
sps.bites0 <- sp.bites0[c(-1,-2,-3,-12)]
sps.benthos0 <- sp.benth0[c(-1,-2,-3,-12)]

# Run strauss index
spstrauss0 <- (sps.bites0-sps.benthos0)

# Make the plot
spstrau0 <- cbind(sp.bites0[,2], spstrauss0)
spstra10 <- melt(spstrau0, variable.name="Category", value.name = "strauss")
View(spstra10)

# Calculate SE
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2 (xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm),
                     sum  = sum    (xx[[col]], na.rm=na.rm),
                     median  = median    (xx[[col]], na.rm=na.rm),
                     min  = min    (xx[[col]], na.rm=na.rm),
                     max  = max    (xx[[col]], na.rm=na.rm),
                     Q = quantile     (xx[[col]], na.rm=na.rm),
                     cv = sd (xx[[col]], na.rm=na.rm) / mean (xx[[col]], na.rm=na.rm) * 100 
                   )
                 },
                 measurevar
  )
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}


spresstr0 <- summarySE(spstra10, measurevar="strauss", groupvar="Category")
View(spresstr0)

# ggplot
spstrau0.plot <- ggplot(spresstr0, aes(x=Category, y=mean)) + 
  geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci), width=.1,position=position_dodge(0.5)) + #keep 
  geom_point(position=position_dodge(0.5)) + 
  geom_hline(yintercept=0, linetype="dotted") + # keep
  ylim(-1,1) + # keep
  ylab("Mean") +
  xlab("Category") +
  labs(title="S. psittacus - No SeS") +
  theme(axis.text.x = element_text(angle = 45, vjust=0.6)) + 
  scale_x_discrete(labels=c("Turf", "Macro", "Coral", "CCA", "Sponge", "Rubble", "Rock", "Other"))
print(spstrau0.plot)
#ggsave("spstrau.jpg", spstrau.plot, width=6, height=4, dpi=300)


```

```{r, PLOT - SELECTIVITY INDEX BARGRAPH, SeS vs. No SeS}

# Build dataframe

abresstr1ses$species <- 'A. blochii'
atresstr1ses$species <- 'A. triostegus'
zfresstr1ses$species <- 'Z. flavescens'
zvresstr1ses$species <- 'Z. velifer'
uniresstr1ses$species <- 'Naso spp.'
csresstr1ses$species <- 'C. spilurus'
spresstr1ses$species <- 'S. psittacus'

abresstr0$species <- 'A. blochii'
atresstr0$species <- 'A. triostegus'
zfresstr0$species <- 'Z. flavescens'
zvresstr0$species <- 'Z. velifer'
uniresstr0$species <- 'Naso spp.'
csresstr0$species <- 'C. spilurus'
spresstr0$species <- 'S. psittacus'

abresstr1ses$ses <- 'SeS'
atresstr1ses$ses <- 'SeS'
zfresstr1ses$ses <- 'SeS'
zvresstr1ses$ses <- 'SeS'
uniresstr1ses$ses <- 'SeS'
csresstr1ses$ses <- 'SeS'
spresstr1ses$ses <- 'SeS'

abresstr0$ses <- 'No SeS'
atresstr0$ses <- 'No SeS'
zfresstr0$ses <- 'No SeS'
zvresstr0$ses <- 'No SeS'
uniresstr0$ses <- 'No SeS'
csresstr0$ses <- 'No SeS'
spresstr0$ses <- 'No SeS'

ncol(abresstr1ses)
ncol(atresstr1ses)
ncol(zfresstr1ses)
ncol(zvresstr1ses)
ncol(csresstr1ses)
ncol(spresstr1ses)
ncol(uniresstr1ses)
ncol(abresstr0)
ncol(atresstr0)
ncol(zfresstr0)
ncol(zvresstr0)
ncol(csresstr0)
ncol(spresstr0)
ncol(uniresstr0)

selectses.dat <- rbind(abresstr1ses, atresstr1ses, zfresstr1ses, zvresstr1ses, uniresstr1ses, csresstr1ses, spresstr1ses, abresstr0, atresstr0, zfresstr0, zvresstr0, uniresstr0, csresstr0, spresstr0)
View(selectses.dat)

# Build barplot and flip coordinates
order.sel <- c("S. psittacus", "C. spilurus", "Naso spp.", "Z. velifer","Z. flavescens", "A. triostegus", "A. blochii")
selectses.dat$species <- factor(selectses.dat$species, levels = order.sel)

# Deposited Sediment (SeS) #
selectses.plot <- ggplot(subset(selectses.dat, ses == "SeS"), aes(x=as.factor(Category),y=mean,fill=species)) +
   geom_bar(position="dodge", stat="identity", color="black", linewidth=0.3) + 
    geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci, group=species),  width=0.3,position=position_dodge(0.9)) + 
   geom_hline(yintercept=0, linetype="dotted") + 
  coord_flip() +
  ylab("Selectivity") +
  xlab("") +
  ylim(-1,1) +
  labs(fill = "Species", title="Deposited Sediment") +
  scale_x_discrete(labels=c("Other", "Rock", "Rubble", "Sponge", "CCA", "Coral", "Macro", "Turf"), limits = rev(levels(selectses.dat$Category))) +
  theme(axis.line.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        plot.background = element_rect(fill = "#D2B48C"), legend.text = element_text(face = "italic")) +
    scale_fill_fish_d(option = "Cirrhilabrus_solorensis", guide=guide_legend(reverse = TRUE))
print(selectses.plot)

# No Deposited Sediment #
selectnoses.plot <- ggplot(subset(selectses.dat, ses == "No SeS"), aes(x=as.factor(Category), y=mean, fill=species)) +
   geom_bar(position="dodge", stat="identity", color="black", linewidth=0.3) + 
    geom_errorbar(aes(ymin= mean-ci, ymax= mean+ci, group=species),  width=0.3,position=position_dodge(0.9)) + 
   geom_hline(yintercept=0, linetype="dotted") + 
  coord_flip() +
  ylab("Selectivity") +
  xlab("") +
  ylim(-1,1) +
  labs(fill = "Species", title="No Deposited Sediment") +
  scale_x_discrete(labels=c("Other", "Rock", "Rubble", "Sponge", "CCA", "Coral", "Macro", "Turf"), limits = rev(levels(selectses.dat$Category))) +
    scale_fill_fish_d(option = "Cirrhilabrus_solorensis", guide=guide_legend(reverse = TRUE)) +
    theme(plot.background = element_rect(fill = "#F5F5DC"), legend.text = element_text(face = "italic"))     #annotation_raster(rock.img, xmin = 1.7, xmax = 2.3, ymin = -1.0, ymax = -0.7) +
 #annotation_raster(rubble.img, xmin = 2.7, xmax = 3.3, ymin = -1.0, ymax = -0.7) +
  #annotation_raster(sponge.img, xmin = 3.6, xmax = 4.4, ymin = -1.0, ymax = -0.8) +
  #annotation_raster(cca.img, xmin = 4.8, xmax = 5.2, ymin = -1.0, ymax = -0.7) +
  #annotation_raster(coral.img, xmin = 5.7, xmax = 6.3, ymin = -1.0, ymax = -0.7) +
  #annotation_raster(macro.img, xmin = 6.7, xmax = 7.3, ymin = -1.0, ymax = -0.7) +
  #annotation_raster(turf.img, xmin = 7.9, xmax = 8.1, ymin = -1.0, ymax = -0.7)
print(selectnoses.plot)

selectses2.plot <- ggarrange(selectnoses.plot,selectses.plot,common.legend=TRUE,legend="right",ncol=2,nrow=1)
print(selectses2.plot)
ggsave("selectses2.plot.jpg", selectses2.plot, width=11, height=7, dpi=300)

```

```{r, T-test for Selectivity Index - SeS/No SeS}
### A. blochii ###
# Add columns and combine dataframes
abstra11ses$sediment <- "ses"
abstra10$sediment <- "no"
# Check column names - must match for rbind
names(abstra11ses)
names(abstra10)
# Change name to match
newabstra10 <- abstra10
names(newabstra10)[names(newabstra10) == "ab.bites0[, 2]"] <- "ab.bites1ses[, 2]"
names(newabstra10)
# Now combine
ab.rbind <- rbind(abstra11ses, newabstra10)

# Subset the data to include only rows where 'category' is equal to 'turf'
ab.subset <- ab.rbind[ab.rbind$Category == "turf", ] # CHANGE FOOD CHOICE HERE
View(ab.subset)

# Separate data into two groups based on the levels of 'sediment'
ab.subses <- ab.subset$strauss[ab.subset$sediment == "ses"]
ab.subno <- ab.subset$strauss[ab.subset$sediment == "no"]

# Perform two-sample t-test
print(t.test(ab.subses, ab.subno)) 
# **Turf: p < 0.001; prefer SeS
# **Macro: p < 0.001; avoid macro more with SeS
# **Coral: p < 0.001; avoid coral less with SeS
# CCA: p < 0.05; avoid less with SeS


### A. triostegus ###
# Add columns and combine dataframes
atstra11ses$sediment <- "ses"
atstra10$sediment <- "no"
# Check column names - must match for rbind
names(atstra11ses)
names(atstra10)
# Change name to match
newatstra10 <- atstra10
names(newatstra10)[names(newatstra10) == "at.bites0[, 2]"] <- "at.bites1ses[, 2]"
names(newatstra10)
# Now combine
at.rbind <- rbind(atstra11ses, newatstra10)

# Subset the data to include only rows where 'category' is equal to 'turf'
at.subset <- at.rbind[at.rbind$Category == "coral", ] # CHANGE FOOD CHOICE HERE

# Separate data into two groups based on the levels of 'sediment'
at.subses <- at.subset$strauss[at.subset$sediment == "ses"]
at.subno <- at.subset$strauss[at.subset$sediment == "no"]

# Perform two-sample t-test
print(t.test(at.subses, at.subno)) 
# **Turf: p < 0.001; prefer SeS
# **Macro: p < 0.001; avoid macro more with SeS
# **Coral: p < 0.001; avoid coral less with SeS
# CCA: p < 0.05; avoid less with SeS

### Z. flavescens ###
# Add columns and combine dataframes
zfstra11ses$sediment <- "ses"
zfstra10$sediment <- "no"
# Check column names - must match for rbind
names(zfstra11ses)
names(zfstra10)
# Change name to match
newzfstra10 <- zfstra10
names(newzfstra10)[names(newzfstra10) == "zf.bites0[, 2]"] <- "zf.bites1ses[, 2]"
names(newzfstra10)
# Now combine
zf.rbind <- rbind(zfstra11ses, newzfstra10)

# Subset the data to include only rows where 'category' is equal to 'turf'
zf.subset <- zf.rbind[zf.rbind$Category == "macro", ] # CHANGE FOOD CHOICE HERE

# Separate data into two groups based on the levels of 'sediment'
zf.subses <- zf.subset$strauss[zf.subset$sediment == "ses"]
zf.subno <- zf.subset$strauss[zf.subset$sediment == "no"]

# Perform two-sample t-test
print(t.test(zf.subses, zf.subno)) 
# **Turf: p < 0.001; prefer SeS

### Z. velifer. ###
# Add columns and combine dataframes
zvstra11ses$sediment <- "ses"
zvstra10$sediment <- "no"
# Check column names - must match for rbind
names(zvstra11ses)
names(zvstra10)
# Change name to match
newzvstra10 <- zvstra10
names(newzvstra10)[names(newzvstra10) == "zv.bites0[, 2]"] <- "zv.bites1ses[, 2]"
names(newzvstra10)
# Now combine
zv.rbind <- rbind(zvstra11ses, newzvstra10)

# Subset the data to include only rows where 'category' is equal to 'turf'
zv.subset <- zv.rbind[zv.rbind$Category == "macro", ] # CHANGE FOOD CHOICE HERE

# Separate data into two groups based on the levels of 'sediment'
zv.subses <- zv.subset$strauss[zv.subset$sediment == "ses"]
zv.subno <- zv.subset$strauss[zv.subset$sediment == "no"]

# Perform two-sample t-test
print(t.test(zv.subses, zv.subno)) 
# **Turf: p < 0.001; prefer SeS
# Macro: p < 0.05; avoid more with SeS
# Coral: p < 0.05; avoid less wtih SeS

### Naso spp. ###
# Add columns and combine dataframes
unistra11ses$sediment <- "ses"
unistra10$sediment <- "no"
# Check column names - must match for rbind
names(unistra11ses)
names(unistra10)
# Change name to match
newunistra10 <- unistra10
names(newunistra10)[names(newunistra10) == "uni.bites0[, 2]"] <- "uni.bites1ses[, 2]"
names(newunistra10)
# Now combine
uni.rbind <- rbind(unistra11ses, newunistra10)

# Subset the data to include only rows where 'category' is equal to 'turf'
uni.subset <- uni.rbind[uni.rbind$Category == "macro", ] # CHANGE FOOD CHOICE HERE

# Separate data into two groups based on the levels of 'sediment'
uni.subses <- uni.subset$strauss[uni.subset$sediment == "ses"]
uni.subno <- uni.subset$strauss[uni.subset$sediment == "no"]

# Perform two-sample t-test
print(t.test(uni.subses, uni.subno)) 
# Macro: p < 0.05; prefer SeS

### C. spilurus ###
# Add columns and combine dataframes
csstra11ses$sediment <- "ses"
csstra10$sediment <- "no"
# Check column names - must match for rbind
names(csstra11ses)
names(csstra10)
# Change name to match
newcsstra10 <- csstra10
names(newcsstra10)[names(newcsstra10) == "cs.bites0[, 2]"] <- "cs.bites1ses[, 2]"
names(newcsstra10)
# Now combine
cs.rbind <- rbind(csstra11ses, newcsstra10)

# Subset the data to include only rows where 'category' is equal to 'turf'
cs.subset <- cs.rbind[cs.rbind$Category == "cca", ] # CHANGE FOOD CHOICE HERE

# Separate data into two groups based on the levels of 'sediment'
cs.subses <- cs.subset$strauss[cs.subset$sediment == "ses"]
cs.subno <- cs.subset$strauss[cs.subset$sediment == "no"]

# Perform two-sample t-test
print(t.test(cs.subses, cs.subno)) 
# **Turf: p < 0.001; prefer SeS
# Macro: p < 0.05; avoid macro less with SeS
# Coral: p <0.05; avoid coral more with SeS
# CCA: p <0.05; avoid CCA more with SeS

### S. psittacus ###
# Add columns and combine dataframes
spstra11ses$sediment <- "ses"
spstra10$sediment <- "no"
# Check column names - must match for rbind
names(spstra11ses)
names(spstra10)
# Change name to match
newspstra10 <- spstra10
names(newspstra10)[names(newspstra10) == "sp.bites0[, 2]"] <- "sp.bites1ses[, 2]"
names(newspstra10)
# Now combine
sp.rbind <- rbind(spstra11ses, newspstra10)
#View(sp.rbind)

# Subset the data to include only rows where 'category' is equal to 'turf'
sp.subset <- sp.rbind[sp.rbind$Category == "coral", ] # CHANGE FOOD CHOICE HERE

# Separate data into two groups based on the levels of 'sediment'
sp.subses <- sp.subset$strauss[sp.subset$sediment == "ses"]
sp.subno <- sp.subset$strauss[sp.subset$sediment == "no"]


# Perform two-sample t-test
print(t.test(sp.subses, sp.subno)) 
# Turf: p < 0.05; prefer SeS
# Coral: p <0.05; avoid coral less with SeS

```

